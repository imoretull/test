// ==========================================
// CONFIGURATION
// ==========================================
// Jira base URL - update this to match your Jira instance
const JIRA_BASE_URL = 'https://enterprise-jira.onefiserv.net/browse/';

// Global state for sort mode
let sortByCriticality = false;
let jiraFilter = 'all'; // 'all', 'with-jira', 'without-jira'
let jiraSortOrder = 'default'; // 'default', 'with-first', 'without-first'

// Global state for testing notes
let testingNotes = '';

// Global state for custom filters
let customFilters = []; // Array of {id, name, config: {priority, status, scope, execType, age, categories}}

// Global state for file config (App-Name, Projects, etc.)
let fileConfig = {};

// ==========================================
// FILE FORMAT PARSER (.tqt format)
// ==========================================
// File format markers for .tqt files:
// [CONFIG] - Configuration settings (future use)
// [NOTES] - Testing notes, todos, reminders
// [DATA] - Test case data (CSV format)
// ===SECTION_END=== - Section divider

function parseTQTFile(fileContent) {
  const result = {
    config: {},
    notes: '',
    data: '',
    customFilters: []
  };

  const configMatch = fileContent.match(/\[CONFIG\](.*?)(===SECTION_END===|\[NOTES\])/s);
  const notesMatch = fileContent.match(/\[NOTES\](.*?)(===SECTION_END===|\[DATA\])/s);
  const dataMatch = fileContent.match(/\[DATA\](.*?)$/s);

  if (configMatch) {
    const configLines = configMatch[1].trim().split('\n');
    configLines.forEach(line => {
      const [key, ...valueParts] = line.split('=');
      if (key && valueParts.length > 0) {
        const keyTrimmed = key.trim();
        const value = valueParts.join('=').trim();

        // Parse custom filters from JSON
        if (keyTrimmed === 'customFilters') {
          try {
            result.customFilters = JSON.parse(value);
          } catch (e) {
            result.customFilters = [];
          }
        } else {
          result.config[keyTrimmed] = value;
        }
      }
    });
  }

  if (notesMatch) {
    result.notes = notesMatch[1].trim();
  }

  if (dataMatch) {
    result.data = dataMatch[1].trim();
  } else {
    // If no [DATA] section found, assume entire content is CSV (legacy format)
    result.data = fileContent.trim();
  }

  return result;
}

function generateTQTFile(config, notes, csvData) {
  let content = '';

  // Config section
  content += '[CONFIG]\n';
  if (config && Object.keys(config).length > 0) {
    for (const [key, value] of Object.entries(config)) {
      content += `${key}=${value}\n`;
    }
  }
  // Include custom filters in config
  if (customFilters && customFilters.length > 0) {
    content += `customFilters=${JSON.stringify(customFilters)}\n`;
  }
  content += '===SECTION_END===\n\n';

  // Notes section
  content += '[NOTES]\n';
  if (notes && notes.trim()) {
    content += notes.trim() + '\n';
  }
  content += '===SECTION_END===\n\n';

  // Data section
  content += '[DATA]\n';
  content += csvData;

  return content;
}

// Apply config settings from .tqt file
function applyConfigSettings(config) {
  // Store config globally so it can be saved back
  fileConfig = { ...config };

  // Apply App-Name to header title
  if (config['App-Name']) {
    const headerTitle = document.querySelector('.header h1');
    if (headerTitle) {
      const icon = headerTitle.querySelector('.header-icon');
      const iconHtml = icon ? icon.outerHTML : '';
      headerTitle.innerHTML = iconHtml + ' <span style="min-width:120px; display:inline-block;">' + config['App-Name'] + '</span>';
    }
    // Also update page title
    document.title = config['App-Name'];
  }

  // Apply Projects to team dropdown
  if (config['Projects']) {
    const teamInput = document.getElementById('teamInput');
    if (teamInput) {
      const projects = config['Projects'].split(',').map(p => p.trim());
      teamInput.innerHTML = '';
      projects.forEach((project, index) => {
        const option = document.createElement('option');
        option.value = project;
        option.textContent = project;
        if (index === 0) option.selected = true;
        teamInput.appendChild(option);
      });
    }
  }
}

// Helper function to compare two Sets
function areSetsEqual(set1, set2) {
  if (set1.size !== set2.size) return false;
  for (const item of set1) {
    if (!set2.has(item)) return false;
  }
  return true;
}

// Function to check if current filters match a quick filter preset
function checkQuickFilterMatch() {
  let matchedFilter = null;
  
  // Check each filter configuration
  const filterConfigs = {
    'show-all': {
      priority: new Set(['C', 'H', 'M', 'L']),
      status: new Set(['N', 'P', 'F', 'B', 'K', 'S']),
      scope: 'R',
      execType: 'Both',
      age: 'Both'
    },
    'issues': {
      priority: new Set(['C', 'H', 'M', 'L']),
      status: new Set(['F', 'B', 'K']),
      scope: 'R',
      execType: 'Both',
      age: 'Both'
    },
    'critical-issues': {
      priority: new Set(['C']),
      status: new Set(['F', 'B', 'K']),
      scope: 'R',
      execType: 'Both',
      age: 'Both'
    },
    'new-features': {
      priority: new Set(['C', 'H', 'M', 'L']),
      status: new Set(['N', 'P', 'F', 'B', 'K', 'S']),
      scope: 'R',
      execType: 'Both',
      age: 'N'
    },
    'not-tested': {
      priority: new Set(['C', 'H', 'M', 'L']),
      status: new Set(['N']),
      scope: 'R',
      execType: 'Both',
      age: 'Both'
    },
    'failed-blocked': {
      priority: new Set(['C', 'H', 'M', 'L']),
      status: new Set(['F', 'B']),
      scope: 'R',
      execType: 'Both',
      age: 'Both'
    },
    'smoke': {
      priority: new Set(['C', 'H', 'M', 'L']),
      status: new Set(['N', 'P', 'F', 'B', 'K', 'S']),
      scope: 'S',
      execType: 'Both',
      age: 'Both'
    },
    'automated': {
      priority: new Set(['C', 'H', 'M', 'L']),
      status: new Set(['N', 'P', 'F', 'B', 'K', 'S']),
      scope: 'R',
      execType: 'A',
      age: 'Both'
    }
  };

  // Check if current filters match any preset
  for (const [filterType, config] of Object.entries(filterConfigs)) {
    const priorityMatch = areSetsEqual(filterPriority, config.priority);
    const statusMatch = areSetsEqual(filterStatus, config.status);
    const scopeMatch = filterTestScope === config.scope;
    const execMatch = filterExecType === config.execType;
    const ageMatch = filterAge === config.age;

    if (priorityMatch && statusMatch && scopeMatch && execMatch && ageMatch) {
      matchedFilter = filterType;
      break;
    }
  }
  
  // Update quick filter button highlights (both types)
  const quickFilterBtns = document.querySelectorAll('.quick-filter-btn, .quick-filter-btn-sidebar');
  quickFilterBtns.forEach(btn => {
    const filterType = btn.getAttribute('data-filter');
    if (filterType === matchedFilter) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
}

// Update Jira filter button appearance
function updateJiraFilterButton() {
  const jiraFilterBtn = document.getElementById('jiraFilterBtn');
  if (!jiraFilterBtn) return;
  
  if (jiraFilter === 'with-jira') {
    jiraFilterBtn.style.background = '#4a90e2';
    jiraFilterBtn.style.color = '#fff';
    jiraFilterBtn.style.borderColor = '#4a90e2';
    jiraFilterBtn.style.fontWeight = '600';
    jiraFilterBtn.textContent = 'üé´ With';
    jiraFilterBtn.title = 'Showing only rows with Jira tickets. Click for: Without Jira';
  } else if (jiraFilter === 'without-jira') {
    jiraFilterBtn.style.background = '#f5c6cb';
    jiraFilterBtn.style.color = '#721c24';
    jiraFilterBtn.style.borderColor = '#f5c6cb';
    jiraFilterBtn.style.fontWeight = '600';
    jiraFilterBtn.textContent = 'üé´ Without';
    jiraFilterBtn.title = 'Showing only rows without Jira tickets. Click for: All';
  } else {
    jiraFilterBtn.style.background = '#f8f9fa';
    jiraFilterBtn.style.color = '#6c7a8a';
    jiraFilterBtn.style.borderColor = '#d1d9e0';
    jiraFilterBtn.style.fontWeight = '500';
    jiraFilterBtn.textContent = 'üé´ Jira';
    jiraFilterBtn.title = 'Filter by Jira: All ‚Üí With Jira ‚Üí Without Jira';
  }
}

// Update Jira sort icon in header
function updateJiraSortIcon() {
  const jiraSortIcon = document.getElementById('jiraSortIcon');
  if (!jiraSortIcon) return;
  
  if (jiraSortOrder === 'with-first') {
    jiraSortIcon.textContent = '‚ñº';
    jiraSortIcon.style.color = '#4a90e2';
    jiraSortIcon.title = 'Sorted: With Jira first';
  } else if (jiraSortOrder === 'without-first') {
    jiraSortIcon.textContent = '‚ñ≤';
    jiraSortIcon.style.color = '#f5a623';
    jiraSortIcon.title = 'Sorted: Without Jira first';
  } else {
    jiraSortIcon.textContent = '';
    jiraSortIcon.title = '';
  }
}

/* ==========================================
   MAIN APPLICATION INITIALIZATION
   ========================================== */

document.addEventListener('DOMContentLoaded', function() {
    // On page load, reset all filters and select Show All quick filter
    setTimeout(() => {
      // Reset all sidebar filters
      filterPriority = new Set(['C', 'H', 'M', 'L']);
      filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);
      filterTestScope = 'R';
      filterExecType = 'Both';
      filterAge = 'Both';
      selectedCategories = new Set();
      jiraFilter = 'all';
      resetSpecialFilters();
      renderTable(csvData);
      checkQuickFilterMatch();
      // Select Show All quick filter button (both types)
      const quickFilterBtns = document.querySelectorAll('.quick-filter-btn, .quick-filter-btn-sidebar');
      quickFilterBtns.forEach(btn => {
        if (btn.getAttribute('data-filter') === 'show-all') {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      // Add Test Case button logic
      const addTestCaseBtn = document.getElementById('addTestCaseBtn');
      if (addTestCaseBtn) {
        addTestCaseBtn.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          console.log('Add button clicked');
          if (typeof closeRowEditor === 'function' && currentlyEditingRow !== null) {
            closeRowEditor();
          }
          // Create a blank row object with defaults
          const blankRow = {
            id: '',
            priority: '',
            status: '',
            category: '',
            testcase: '',
            notes: '',
            jira: '',
            type: '',
            scope: ''
          };
          // Auto-populate category if only one category is currently filtered
          if (selectedCategories.size === 1) {
            const [singleCategory] = selectedCategories;
            blankRow.category = singleCategory;
          }
          // Call createRowEditor with -1 as index for new row
          createRowEditor(blankRow, -1, null);
        });
      }
      // Enable/disable Reset Filters button based on filter state
      function updateResetBtnState() {
        const resetBtn = document.getElementById('resetFiltersBtn');
        const isDefault = (
          areSetsEqual(filterPriority, new Set(['C', 'H', 'M', 'L'])) &&
          areSetsEqual(filterStatus, new Set(['N', 'P', 'F', 'B', 'K', 'S'])) &&
          filterTestScope === 'R' &&
          filterExecType === 'Both' &&
          filterAge === 'Both' &&
          selectedCategories.size === 0 &&
          jiraFilter === 'all' &&
          !filterPinned && !filterQuestions && !filterRetest && !filterPendingJira && !filterCleanup
        );
        if (resetBtn) {
          resetBtn.disabled = isDefault;
          resetBtn.classList.toggle('disabled', isDefault);
        }
      }
      // Call on load and after any filter change
      updateResetBtnState();
      // Listen for filter changes to update button state
      [
        ...document.querySelectorAll('.priority-filter-btn, .filter-radio input, #categoryDropdownBtn, .quick-filter-btn, .quick-filter-btn-sidebar, #jiraFilterBtn, #pinFilterBtn, #questionFilterBtn, #retestFilterBtn, #pendingJiraFilterBtn, #cleanupFilterBtn')
      ].forEach(el => {
        el.addEventListener('click', () => setTimeout(updateResetBtnState, 10));
      });
    }, 500);

    // Intercept filter and quick filter interactions while in CSV edit mode
    function promptEditModeExit(e) {
      if (csvEditMode) {
        e.preventDefault();
        e.stopPropagation();
        alert('You are currently editing test cases. Please Save or Cancel your changes before using filters.');
        return true;
      }
      return false;
    }

  // ==========================================
  // CSV EDIT MODE - Bulk text editing
  // ==========================================
  let csvEditMode = false;
  let csvEditContainer = null;
  let csvEditTextarea = null;
  let csvInstructionBanner = null;
  let csvSaveBtn = null;
  let csvCancelBtn = null;
  let csvErrorMsg = null;
  let originalCsvContent = '';
  const testTable = document.getElementById('testTable');
  const toggleCsvEditBtn = document.getElementById('toggleCsvEditBtn');
  
  function getFilteredData(data) {
    // Apply current filters to get only visible rows
    return data.filter(row => {
      let execMatch = true;
      if (filterExecType === 'M') execMatch = (row.type !== 'A');
      else if (filterExecType === 'A') execMatch = (row.type === 'A');
      let scopeMatch = true;
      if (filterTestScope === 'Y') {
        // Sanity: smallest subset (prod testing)
        scopeMatch = (row.scope === 'Y');
      } else if (filterTestScope === 'S') {
        // Smoke: includes Smoke + Sanity
        scopeMatch = (row.scope === 'S' || row.scope === 'Y');
      } else if (filterTestScope === 'R') {
        // Regression: includes all (R + S + Y)
        scopeMatch = (row.scope === 'R' || row.scope === 'S' || row.scope === 'Y');
      }
      // Age filter
      let ageMatch = true;
      if (filterAge === 'N') {
        ageMatch = (row.age === 'N');
      } else if (filterAge === 'O') {
        ageMatch = (row.age === 'O' || !row.age);
      }
      // Both = show all
      // Priority filter only applies to bugs (Failed/Blocked) - other statuses ignore priority
      const isBugStatus = (row.status === 'F' || row.status === 'B');
      let priorityMatch = filterPriority.size === 4 || !isBugStatus || filterPriority.has(row.priority);
      let statusMatch = filterStatus.has(row.status || 'N');
      let testCaseMatch = true;
      if (filterTestCase.trim()) {
        const keyword = filterTestCase.toLowerCase();
        const testcase = (row.testcase || '').toLowerCase();
        const notes = (row.notes || '').toLowerCase();
        testCaseMatch = testcase.includes(keyword) || notes.includes(keyword);
      }
      // Category filter
      const cat = row.category || 'Uncategorized';
      let categoryMatch = (selectedCategories === null) ? false : (selectedCategories.size === 0 || selectedCategories.has(cat));

      // Jira filter
      let jiraMatch = true;
      if (jiraFilter === 'with-jira') {
        jiraMatch = !!(row.jira && row.jira.trim());
      } else if (jiraFilter === 'without-jira') {
        jiraMatch = !(row.jira && row.jira.trim());
      }

      // Quick filters (prefix-based)
      let pinMatch = true;
      if (filterPinned) {
        pinMatch = (row.testcase || '').startsWith('*');
      }
      let questionMatch = true;
      if (filterQuestions) {
        questionMatch = (row.testcase || '').startsWith('?');
      }
      let retestMatch = true;
      if (filterRetest) {
        retestMatch = (row.testcase || '').startsWith('@');
      }
      let pendingJiraMatch = true;
      if (filterPendingJira) {
        pendingJiraMatch = (row.testcase || '').startsWith('!');
      }
      let cleanupMatch = true;
      if (filterCleanup) {
        cleanupMatch = (row.testcase || '').startsWith('~');
      }

      return execMatch && scopeMatch && ageMatch && priorityMatch && statusMatch && testCaseMatch && categoryMatch && jiraMatch && pinMatch && questionMatch && retestMatch && pendingJiraMatch && cleanupMatch;
    });
  }

  function generateCsvWithLineBreaks(data) {
    // Sort by category to group them
    const sortedData = [...data].sort((a, b) => {
      const catA = a.category || '';
      const catB = b.category || '';
      return catA.localeCompare(catB);
    });
    
    let csvLines = [];
    let lastCategory = null;
    
    // Add header without any ID columns
    csvLines.push('type,scope,age,priority,status,category,testcase,notes,jira');

    sortedData.forEach((row) => {
      const {id, _originalId, ...rest} = row;
      const currentCategory = rest.category || '';

      // Add blank line when category changes
      if (lastCategory !== null && lastCategory !== currentCategory) {
        csvLines.push('');
      }

      // Add data row
      const values = [
        rest.type || '',
        rest.scope || '',
        rest.age || '',
        rest.priority || '',
        rest.status || '',
        rest.category || '',
        rest.testcase || '',
        rest.notes || '',
        rest.jira || ''
      ];
      
      // Properly escape CSV values
      const escapedValues = values.map(v => {
        const str = String(v);
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
          return '"' + str.replace(/"/g, '""') + '"';
        }
        return str;
      });
      
      csvLines.push(escapedValues.join(','));
      lastCategory = currentCategory;
    });
    
    return csvLines.join('\n');
  }
  
  function parseCsvAndValidate(csvText, isFiltered, fullData) {
    // Define valid values for CSV columns (used for validation)
    const validType = ['M', 'A'];
    const validScope = ['R', 'S', 'Y']; // R=Regression, S=Smoke, Y=Sanity (prod)
    const validPriority = ['C', 'H', 'M', 'L', '-'];
    const validStatus = ['N', 'P', 'F', 'B', 'K', 'S'];
    // validAge is used implicitly in parsing - N=New, O=Old/Established
    // Helper to count unquoted commas in a line (ignores commas inside quotes)
    function countUnquotedCommas(line) {
      let count = 0;
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          // Toggle quote state (basic CSV assumption)
          inQuotes = !inQuotes;
        } else if (ch === ',' && !inQuotes) {
          count++;
        }
      }
      return count;
    }
    const rawLines = csvText.split(/\r?\n/);
    
    // Collect all errors instead of returning early
    const allErrors = [];

    try {
      const parsed = Papa.parse(csvText.trim(), {
        header: true,
        skipEmptyLines: 'greedy',
        transformHeader: (h) => h.trim().toLowerCase()
      });
      
      // Check for parsing errors
      if (parsed.errors && parsed.errors.length > 0) {
        const criticalErrors = parsed.errors.filter(e => e.type === 'FieldMismatch' || e.type === 'Quotes');
        if (criticalErrors.length > 0) {
          const errorDetails = criticalErrors.map(e => {
            const lineNum = e.row + 2;
            const lineContent = rawLines[lineNum - 1] || '';
            return `Line ${lineNum}: ${e.message}\n  ‚Üí ${lineContent}`;
          }).join('\n\n');
          allErrors.push('CSV Format Error:\n' + errorDetails + '\n\nPlease check for missing/extra commas or unmatched quotes.');
        }
      }
      
      // Validate required columns (first six mandatory; notes and jira optional)
      const requiredColumns = ['type','scope','priority','status','category','testcase'];
      const headers = parsed.meta.fields || [];
      const missingColumns = requiredColumns.filter(col => !headers.includes(col));
      
      if (missingColumns.length > 0) {
        allErrors.push(`Missing required column(s): ${missingColumns.join(', ')}\n\nExpected columns: type, scope, priority, status, category, testcase, notes, jira`);
      }

      // Comma count validation for each data line (unquoted commas)
      const expectedCommaCount = headers.length - 1; // commas per line
      const headerLineIndex = rawLines.findIndex(l => l.trim());
      const commaErrors = [];
      rawLines.forEach((line, idx) => {
        const trimmed = line.trim();
        if (!trimmed) return; // skip blank
        if (idx === headerLineIndex) return; // skip header
        const actual = countUnquotedCommas(line);
        if (actual !== expectedCommaCount) {
          commaErrors.push(`Line ${idx + 1}: Expected ${expectedCommaCount} commas, found ${actual}\n  ‚Üí ${line}`);
        }
      });
      if (commaErrors.length > 0) {
        allErrors.push('CSV Comma Error(s):\n' + commaErrors.join('\n\n') + `\n\nEach row must have ${expectedCommaCount} commas for ${headers.length} columns.`);
      }
      
      // Remove id and _originalid columns if present
      let newData = parsed.data.map((row) => {
        const {id, _originalid, ...rest} = row;
        return {...rest};
      });
      
      // Remove completely empty rows
      newData = newData.filter(row => Object.values(row).some(v => v && v.trim && v.trim() !== ''));

      // Validate values in the first four columns for each row
      let errors = [];
      let dataRowIndex = 0;
      newData.forEach((row, idx) => {
        const rowNum = idx + 2; // +2 for header and 1-based index
        
        // Find the actual line in rawLines (skip header and empty lines)
        let actualLineNum = headerLineIndex + 1 + dataRowIndex;
        while (actualLineNum < rawLines.length && !rawLines[actualLineNum].trim()) {
          actualLineNum++;
        }
        const lineContent = rawLines[actualLineNum] || '';
        dataRowIndex++;
        
        if (row.type && !validType.includes(row.type.trim())) {
          errors.push(`Row ${rowNum}: Invalid Type '${row.type}'. Allowed: ${validType.join(', ')}\n  ‚Üí ${lineContent}`);
        }
        if (row.scope && !validScope.includes(row.scope.trim())) {
          errors.push(`Row ${rowNum}: Invalid Scope '${row.scope}'. Allowed: ${validScope.join(', ')}\n  ‚Üí ${lineContent}`);
        }
        if (row.priority && !validPriority.includes(row.priority.trim())) {
          errors.push(`Row ${rowNum}: Invalid Priority '${row.priority}'. Allowed: ${validPriority.join(', ')}\n  ‚Üí ${lineContent}`);
        }
        if (row.status && !validStatus.includes(row.status.trim())) {
          errors.push(`Row ${rowNum}: Invalid Status '${row.status}'. Allowed: ${validStatus.join(', ')}\n  ‚Üí ${lineContent}`);
        }
      });
      if (errors.length > 0) {
        allErrors.push('CSV Value Error(s):\n' + errors.join('\n\n') + '\n\nPlease check the first four columns for typos or invalid values.');
      }
      
      // Return all collected errors or success
      if (allErrors.length > 0) {
        return {
          success: false,
          error: allErrors.join('\n\n' + '='.repeat(60) + '\n\n')
        };
      }
      
      // Validate that we have at least one test case
      if (newData.length === 0) {
        allErrors.push('No valid test cases found. Please add at least one test case.');
      }
      
      // Return all collected errors if any exist
      if (allErrors.length > 0) {
        return {
          success: false,
          error: allErrors.join('\n\n' + '='.repeat(60) + '\n\n')
        };
      }
      
      // If this is a filtered edit, replace the filtered section with edited rows
      if (isFiltered && fullData) {
        // Get the IDs of all rows that were in the filtered view
        const filteredData = getFilteredData(fullData);
        const filteredIds = new Set(filteredData.map(r => parseInt(r.id, 10)));
        
        // Split full dataset into: before filtered, filtered (to be replaced), after filtered
        let firstFilteredIdx = -1;
        let lastFilteredIdx = -1;
        
        fullData.forEach((row, idx) => {
          const rowId = parseInt(row.id, 10);
          if (filteredIds.has(rowId)) {
            if (firstFilteredIdx === -1) firstFilteredIdx = idx;
            lastFilteredIdx = idx;
          }
        });
        
        // Build the final dataset
        const beforeFiltered = firstFilteredIdx > 0 ? fullData.slice(0, firstFilteredIdx) : [];
        const afterFiltered = lastFilteredIdx < fullData.length - 1 ? fullData.slice(lastFilteredIdx + 1) : [];
        
        // Combine: before + edited + after
        const finalData = [
          ...beforeFiltered,
          ...newData,
          ...afterFiltered
        ];
        
        // Regenerate IDs sequentially from 1
        finalData.forEach((row, idx) => { row.id = (idx + 1).toString(); });
        
        return {
          success: true,
          data: finalData
        };
      } else {
        // Full dataset edit - regenerate IDs
        newData.forEach((row, idx) => { row.id = (idx + 1).toString(); });
        
        return {
          success: true,
          data: newData
        };
      }
    } catch (e) {
      return {
        success: false,
        error: 'CSV Parse Error: ' + e.message + '\n\nPlease check your CSV formatting.'
      };
    }
  }
  
  function showCsvEdit() {
    if (!csvEditContainer) {
      // Create container
      csvEditContainer = document.createElement('div');
      csvEditContainer.id = 'csvEditContainer';
      csvEditContainer.style.width = '100%';
      csvEditContainer.style.margin = '12px 0';
      csvEditContainer.style.display = 'none';
      
      // Create instruction banner
      csvInstructionBanner = document.createElement('div');
      csvInstructionBanner.style.padding = '16px 20px';
      csvInstructionBanner.style.background = 'linear-gradient(180deg, #f5f9ff 0%, #eaf4ff 100%)';
      csvInstructionBanner.style.color = '#2d3a4a';
      csvInstructionBanner.style.borderRadius = '6px 6px 0 0';
      csvInstructionBanner.style.fontSize = '12px';
      csvInstructionBanner.style.fontWeight = '500';
      csvInstructionBanner.style.marginBottom = '0';
      csvInstructionBanner.style.border = '2px solid #4a90e2';
      csvInstructionBanner.style.borderBottom = 'none';
      csvInstructionBanner.style.boxShadow = '0 2px 6px rgba(74, 144, 226, 0.08)';
      csvInstructionBanner.innerHTML = `
        <div style="display: flex; flex-direction: row; justify-content: flex-start; align-items: flex-start; gap: 36px;">
          <div style="flex: 1 1 0; min-width: 0; background: #eaf2fb; border: 1px solid #d0e2f6; border-left: 5px solid #4a90e2; border-radius: 7px; padding: 10px 16px; box-shadow: 0 2px 8px 0 #e0e8f8;">
            <div style=\"font-size: 13px; font-weight: 600; margin-bottom: 5px; color: #4a90e2;\">üìù CSV Editor <span id=\"csvFilterStatus\" style=\"font-size: 11px; font-weight: 500; color: #6c7a8a;\"></span></div>
            <ul style=\"margin: 0 0 0 18px; padding: 0; list-style: disc; color: #5a6a8a; font-size: 11px; line-height: 1.7;\">
              <li>Edit, add, delete, and reorder test cases in the CSV</li>
              <li>Validation: Errors are shown live; all issues must be fixed to save</li>
              <li>Blank lines allowed for grouping</li>
              <li><b>Ctrl+S</b>/<b>Cmd+S</b>: Save &nbsp; <b>Ctrl+Enter</b>/<b>Cmd+Enter</b>: Validate &nbsp; <b>Esc</b>: Cancel</li>
            </ul>
          </div>
          <div style="flex: 0 0 500px; margin-left: 32px; background: #f8fafc; border-radius: 7px; border: 1px solid #e1e4e8; padding: 10px 16px; font-size: 11px; color: #2d3a4a; line-height: 1.6; box-shadow: 0 2px 8px 0 #f0f4fa; display: flex; flex-direction: column; align-items: flex-start;">
            <div style="font-weight: 700; color: #205080; margin-bottom: 7px; font-size: 12px; letter-spacing: 0.5px;">Legend</div>
            <div><b>Type:</b> <b>M</b> = Manual, <b>A</b> = Automated</div>
            <div><b>Scope:</b> <b>R</b> = Regression, <b>S</b> = Smoke, <b>N</b> = New</div>
            <div><b>Priority:</b> <b>C</b> = Critical, <b>H</b> = High, <b>M</b> = Medium, <b>L</b> = Low</div>
            <div><b>Status:</b> <b>N</b> = Not Tested, <b>P</b> = Passed, <b>F</b> = Failed, <b>B</b> = Blocked, <b>K</b> = Known Issue, <b>S</b> = Skipped</div>
          </div>
        </div>
      `;
      csvEditContainer.appendChild(csvInstructionBanner);
      
      // Create textarea
      csvEditTextarea = document.createElement('textarea');
      csvEditTextarea.id = 'csvEditTextarea';
      csvEditTextarea.style.width = '100%';
      csvEditTextarea.style.height = '450px';
      csvEditTextarea.style.fontFamily = 'Monaco, Consolas, "Courier New", monospace';
      csvEditTextarea.style.fontSize = '11.5px';
      csvEditTextarea.style.padding = '12px';
      csvEditTextarea.style.border = '2px solid #4a90e2';
      csvEditTextarea.style.borderTop = 'none';
      csvEditTextarea.style.borderRadius = '0 0 6px 6px';
      csvEditTextarea.style.background = 'white';
      csvEditTextarea.style.outline = 'none';
      csvEditTextarea.style.resize = 'vertical';
      csvEditTextarea.style.boxSizing = 'border-box';
      csvEditTextarea.style.whiteSpace = 'pre';
      csvEditTextarea.style.overflowX = 'auto';
      csvEditTextarea.style.overflowY = 'auto';
      csvEditTextarea.style.wordWrap = 'off';
      csvEditTextarea.style.boxShadow = '0 3px 10px rgba(74, 144, 226, 0.12), 0 1px 3px rgba(0, 0, 0, 0.08)';
      csvEditTextarea.wrap = 'off';
      csvEditTextarea.spellcheck = false;
      
      // Add keyboard shortcuts for save (Ctrl+S / Cmd+S) and cancel (Esc)
      csvEditTextarea.addEventListener('keydown', function(e) {
        // Ctrl+S or Cmd+S to save
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          if (!csvSaveBtn.style.display || csvSaveBtn.style.display !== 'none') {
            if (confirm('Save CSV changes and return to table view?')) {
              csvSaveBtn.click();
            }
          }
        }
        // Esc to cancel
        if (e.key === 'Escape') {
          e.preventDefault();
          csvCancelBtn.click();
        }
      });
      
      // Add focus/blur visual feedback
      csvEditTextarea.addEventListener('focus', function() {
        this.style.borderColor = '#357ab8';
        this.style.boxShadow = '0 0 0 3px rgba(74, 144, 226, 0.15), 0 3px 10px rgba(74, 144, 226, 0.12)';
      });
      csvEditTextarea.addEventListener('blur', function() {
        this.style.borderColor = '#4a90e2';
        this.style.boxShadow = '0 3px 10px rgba(74, 144, 226, 0.12), 0 1px 3px rgba(0, 0, 0, 0.08)';
      });
      
      // Add input listener to detect changes
      csvEditTextarea.addEventListener('input', function() {
        const hasChanges = csvEditTextarea.value !== originalCsvContent;
        // Real-time error checking (structure + values)
        const isFiltered = csvEditContainer.dataset.isFiltered === 'true';
        const result = parseCsvAndValidate(csvEditTextarea.value, isFiltered, csvData);
        
        if (!result.success) {
          csvErrorMsg.textContent = result.error;
          csvErrorMsg.style.display = 'block';
          // Reset styling to error colors if previously success
          csvErrorMsg.style.background = '#fee';
          csvErrorMsg.style.border = '1px solid #fcc';
          csvErrorMsg.style.color = '#c33';
          // Hide Save button when there are errors
          csvSaveBtn.style.display = 'none';
        } else {
          csvErrorMsg.style.display = 'none';
          // Only show Save button if there are changes AND no errors
          if (hasChanges) {
            csvSaveBtn.style.display = '';
          } else {
            csvSaveBtn.style.display = 'none';
          }
        }
      });
      
      csvEditContainer.appendChild(csvEditTextarea);
      
      // Create error message div
      csvErrorMsg = document.createElement('div');
      csvErrorMsg.id = 'csvErrorMsg';
      csvErrorMsg.style.display = 'none';
      csvErrorMsg.style.padding = '12px 16px';
      csvErrorMsg.style.marginTop = '14px';
      csvErrorMsg.style.background = 'linear-gradient(135deg, #ffebee 0%, #ffd6da 100%)';
      csvErrorMsg.style.border = '1px solid #ef5350';
      csvErrorMsg.style.borderRadius = '5px';
      csvErrorMsg.style.color = '#c62828';
      csvErrorMsg.style.fontSize = '12px';
      csvErrorMsg.style.fontWeight = '500';
      csvErrorMsg.style.whiteSpace = 'pre-wrap';
      csvErrorMsg.style.fontFamily = 'monospace';
      csvErrorMsg.style.boxShadow = '0 2px 5px rgba(239, 83, 80, 0.15)';
      csvEditContainer.appendChild(csvErrorMsg);
      
      // Create button container
      const btnContainer = document.createElement('div');
      btnContainer.style.marginTop = '16px';
      btnContainer.style.display = 'flex';
      btnContainer.style.gap = '8px';
      btnContainer.style.justifyContent = 'flex-start';
      
      // Create Validate button
      const csvValidateBtn = document.createElement('button');
      csvValidateBtn.textContent = '‚úîÔ∏è Validate';
      csvValidateBtn.title = 'Check for errors without saving (Ctrl+Enter / Cmd+Enter)';
      csvValidateBtn.style.padding = '7px 16px';
      csvValidateBtn.style.fontSize = '12px';
      csvValidateBtn.style.borderRadius = '5px';
      csvValidateBtn.style.border = '1px solid #357ab8';
      csvValidateBtn.style.background = 'linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%)';
      csvValidateBtn.style.color = '#1565c0';
      csvValidateBtn.style.cursor = 'pointer';
      csvValidateBtn.style.fontWeight = '600';
      csvValidateBtn.style.letterSpacing = '0.3px';
      csvValidateBtn.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.08)';
      csvValidateBtn.style.transition = 'all 0.2s ease';
      csvValidateBtn.addEventListener('mouseenter', function() {
        this.style.background = 'linear-gradient(135deg, #e3f2fd 0%, #d1e8fa 100%)';
        this.style.borderColor = '#1565c0';
        this.style.transform = 'translateY(-1px)';
        this.style.boxShadow = '0 2px 5px rgba(74, 144, 226, 0.25)';
      });
      csvValidateBtn.addEventListener('mouseleave', function() {
        this.style.background = 'linear-gradient(135deg, #ffffff 0%, #f5f9ff 100%)';
        this.style.borderColor = '#357ab8';
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.08)';
      });
      csvValidateBtn.addEventListener('mousedown', function() {
        this.style.transform = 'translateY(1px)';
        this.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.08)';
      });
      csvValidateBtn.addEventListener('mouseup', function() {
        this.style.transform = 'translateY(0)';
      });
      csvValidateBtn.addEventListener('click', function() {
        csvErrorMsg.style.display = 'none';
        const isFiltered = csvEditContainer.dataset.isFiltered === 'true';
        const result = parseCsvAndValidate(csvEditTextarea.value, isFiltered, csvData);
        if (!result.success) {
          csvErrorMsg.textContent = result.error;
          csvErrorMsg.style.display = 'block';
          csvEditTextarea.focus();
        } else {
          csvErrorMsg.textContent = 'No errors found.';
          csvErrorMsg.style.background = '#e6ffe6';
          csvErrorMsg.style.border = '1px solid #b2e6b2';
          csvErrorMsg.style.color = '#217a3a';
          csvErrorMsg.style.fontSize = '10px';
          csvErrorMsg.style.display = 'block';
          setTimeout(() => {
            csvErrorMsg.style.display = 'none';
            csvErrorMsg.style.background = '#fee';
            csvErrorMsg.style.border = '1px solid #fcc';
            csvErrorMsg.style.color = '#c33';
            csvErrorMsg.style.fontSize = '';
          }, 1200);
        }
      });
      btnContainer.appendChild(csvValidateBtn);
      // Create Save button
      csvSaveBtn = document.createElement('button');
      csvSaveBtn.textContent = 'üíæ Save Changes';
      csvSaveBtn.title = 'Apply CSV changes and return to table view (Ctrl+S / Cmd+S)';
      csvSaveBtn.style.padding = '7px 16px';
      csvSaveBtn.style.fontSize = '12px';
      csvSaveBtn.style.borderRadius = '5px';
      csvSaveBtn.style.border = '1px solid #357ab8';
      csvSaveBtn.style.background = 'linear-gradient(135deg, #4a90e2 0%, #357ab8 100%)';
      csvSaveBtn.style.color = 'white';
      csvSaveBtn.style.cursor = 'pointer';
      csvSaveBtn.style.fontWeight = '600';
      csvSaveBtn.style.letterSpacing = '0.3px';
      csvSaveBtn.style.boxShadow = '0 2px 5px rgba(74, 144, 226, 0.25)';
      csvSaveBtn.style.transition = 'all 0.2s ease';
      csvSaveBtn.style.display = 'none'; // Hidden by default until changes are made
      csvSaveBtn.addEventListener('mouseenter', function() {
        if (!this.disabled) {
          this.style.background = 'linear-gradient(135deg, #357ab8 0%, #2d6aa3 100%)';
          this.style.boxShadow = '0 3px 8px rgba(74, 144, 226, 0.35)';
          this.style.transform = 'translateY(-1px)';
        }
      });
      csvSaveBtn.addEventListener('mouseleave', function() {
        if (!this.disabled) {
          this.style.background = 'linear-gradient(135deg, #4a90e2 0%, #357ab8 100%)';
          this.style.boxShadow = '0 2px 5px rgba(74, 144, 226, 0.25)';
          this.style.transform = 'translateY(0)';
        }
      });
      csvSaveBtn.addEventListener('mousedown', function() {
        if (!this.disabled) {
          this.style.transform = 'translateY(1px)';
          this.style.boxShadow = '0 1px 2px rgba(74, 144, 226, 0.25)';
        }
      });
      csvSaveBtn.addEventListener('mouseup', function() {
        if (!this.disabled) {
          this.style.transform = 'translateY(0)';
        }
      });
      csvSaveBtn.addEventListener('click', function() {
        csvErrorMsg.style.display = 'none';
        const isFiltered = csvEditContainer.dataset.isFiltered === 'true';
        const result = parseCsvAndValidate(csvEditTextarea.value, isFiltered, csvData);
        
        if (!result.success) {
          csvErrorMsg.textContent = result.error;
          csvErrorMsg.style.display = 'block';
          csvEditTextarea.focus();
          return;
        }
        
        csvData = result.data;
        hideCsvEdit();
        renderTable(csvData);
        renderCategorySummary(csvData);
        saveToCache && saveToCache();
      });
      btnContainer.appendChild(csvSaveBtn);
      
      // Create Cancel button
      csvCancelBtn = document.createElement('button');
      csvCancelBtn.textContent = '‚úñ Cancel';
      csvCancelBtn.title = 'Discard changes and return to table view (Esc)';
      csvCancelBtn.style.padding = '7px 16px';
      csvCancelBtn.style.fontSize = '12px';
      csvCancelBtn.style.borderRadius = '5px';
      csvCancelBtn.style.border = '1px solid #90caf9';
      csvCancelBtn.style.background = 'linear-gradient(135deg, #e3f2fd 0%, #d1e8fa 100%)';
      csvCancelBtn.style.color = '#1565c0';
      csvCancelBtn.style.cursor = 'pointer';
      csvCancelBtn.style.fontWeight = '600';
      csvCancelBtn.style.letterSpacing = '0.3px';
      csvCancelBtn.style.boxShadow = '0 1px 3px rgba(0, 0, 0, 0.08)';
      csvCancelBtn.style.transition = 'all 0.2s ease';
      csvCancelBtn.addEventListener('mouseenter', function() {
        this.style.background = 'linear-gradient(135deg, #bbdefb 0%, #a8d5f7 100%)';
        this.style.borderColor = '#64b5f6';
        this.style.color = '#0d47a1';
        this.style.transform = 'translateY(-1px)';
      });
      csvCancelBtn.addEventListener('mouseleave', function() {
        this.style.background = 'linear-gradient(135deg, #e3f2fd 0%, #d1e8fa 100%)';
        this.style.borderColor = '#90caf9';
        this.style.color = '#1565c0';
        this.style.transform = 'translateY(0)';
      });
      csvCancelBtn.addEventListener('mousedown', function() {
        this.style.transform = 'translateY(1px)';
        this.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.08)';
      });
      csvCancelBtn.addEventListener('mouseup', function() {
        this.style.transform = 'translateY(0)';
      });
      csvCancelBtn.addEventListener('click', function() {
        const hasChanges = csvEditTextarea.value !== originalCsvContent;
        if (hasChanges) {
          if (confirm('Are you sure you want to discard your changes?')) {
            hideCsvEdit();
          }
        } else {
          hideCsvEdit();
        }
      });
      btnContainer.appendChild(csvCancelBtn);
      
      csvEditContainer.appendChild(btnContainer);
      testTable.parentNode.insertBefore(csvEditContainer, testTable);
    }
    
    // Check if any filters are active
    const hasActiveFilters = (
      filterPriority.size < 4 ||
      filterStatus.size < 6 ||
      filterTestScope !== 'R' ||
      filterExecType !== 'Both' ||
      filterTestCase.trim() !== '' ||
      (selectedCategories !== null && selectedCategories.size > 0)
    );
    
    let dataToEdit;

    if (hasActiveFilters) {
      // Get filtered data with original IDs tracked
      dataToEdit = getFilteredData(csvData).map(row => ({
        ...row,
        _originalId: row.id
      }));
      csvEditContainer.dataset.isFiltered = 'true';
      
      // Update instruction banner
      const filterStatus = document.getElementById('csvFilterStatus');
      if (filterStatus) {
        filterStatus.textContent = `(Editing ${dataToEdit.length} filtered rows)`;
      }
    } else {
      // No filters - edit full dataset
      dataToEdit = csvData;
      csvEditContainer.dataset.isFiltered = 'false';
      
      const filterStatus = document.getElementById('csvFilterStatus');
      if (filterStatus) {
        filterStatus.textContent = `(Editing all ${dataToEdit.length} rows)`;
      }
    }
    
    // Generate CSV with line breaks between categories (no IDs)
    const csvContent = generateCsvWithLineBreaks(dataToEdit);
    csvEditTextarea.value = csvContent;
    originalCsvContent = csvContent;
    csvErrorMsg.style.display = 'none';
    
    // Reset Save button state (hidden until changes made)
    csvSaveBtn.style.display = 'none';
    
    testTable.style.display = 'none';
    csvEditContainer.style.display = 'block';
    if (toggleCsvEditBtn) toggleCsvEditBtn.style.display = 'none';
    
    // Hide row count display
    const rowCountDiv = document.getElementById('rowCountDisplay');
    if (rowCountDiv) rowCountDiv.style.display = 'none';
    
    csvEditMode = true;
    
    // Focus textarea and scroll to bottom so buttons are visible
    setTimeout(() => {
      csvEditTextarea.focus();
      csvEditTextarea.setSelectionRange(0, 0);
      csvEditTextarea.scrollTop = 0;
      // Scroll to bottom of page to show Validate/Cancel buttons
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }, 100);
  }
  
  function hideCsvEdit() {
    if (csvEditContainer) {
      csvEditContainer.style.display = 'none';
    }
    testTable.style.display = '';
    if (toggleCsvEditBtn) toggleCsvEditBtn.style.display = '';
    
    // Show row count display
    const rowCountDiv = document.getElementById('rowCountDisplay');
    if (rowCountDiv) rowCountDiv.style.display = '';
    
    csvEditMode = false;
  }
  
  if (toggleCsvEditBtn && testTable) {
    toggleCsvEditBtn.addEventListener('click', function() {
      if (!csvEditMode) {
        showCsvEdit();
      }
    });
  }
        // Close All Areas dropdown when hovering over metrics cards
        function closeCategoryDropdown() {
          const list = document.getElementById('categoryDropdownList');
          if (list && list.style.display === 'block') {
            list.style.display = 'none';
          }
        }
        // Delegate hover to metrics cards
        document.addEventListener('mouseover', function(e) {
          const metricsCard = e.target.closest('.metric-card');
          if (metricsCard) {
            closeCategoryDropdown();
          }
        });
    // Test Case/Notes filter textbox logic
    const testcaseNotesFilter = document.getElementById('testcaseNotesFilter');
    if (testcaseNotesFilter) {
      testcaseNotesFilter.value = filterTestCase || '';
      testcaseNotesFilter.addEventListener('input', function() {
        filterTestCase = this.value;
        saveToCache && saveToCache();
        renderTable(csvData);
      });
    }

    // --- Custom Category Dropdown Logic ---
    const categoryDropdownBtn = document.getElementById('categoryDropdownBtn');
    const categoryDropdownList = document.getElementById('categoryDropdownList');
    const categoryDropdownLabel = document.getElementById('categoryDropdownLabel');

    function updateCategoryDropdown() {
      if (!categoryDropdownList) return;
      categoryDropdownList.innerHTML = '';
      const categories = getUniqueCategories();
      // 'Unselect All' option
      const unselectDiv = document.createElement('div');
      unselectDiv.style.padding = '2px 16px 2px 8px';
      unselectDiv.style.cursor = 'pointer';
      unselectDiv.style.color = '#c0392b';
      unselectDiv.style.fontWeight = 'bold';
      unselectDiv.appendChild(document.createTextNode('Unselect All'));
      unselectDiv.addEventListener('click', function(e) {
        e.stopPropagation();
        selectedCategories = null;
        // Clear all quick/custom filter highlights when manually changing categories
        if (typeof window.clearAllFilterButtonHighlights === 'function') {
          window.clearAllFilterButtonHighlights();
        }
        updateCategoryDropdown();
        updateCategoryDropdownLabel();
        saveToCache && saveToCache();
        renderTable(csvData);
        renderCategorySummary(csvData);
      });
      categoryDropdownList.appendChild(unselectDiv);
      // 'All' option
      const allChecked = selectedCategories && (selectedCategories.size === 0 || selectedCategories.size === categories.length);
      const allDiv = document.createElement('div');
      allDiv.style.padding = '2px 16px 2px 8px';
      allDiv.style.cursor = 'pointer';
      const allCheckbox = document.createElement('input');
      allCheckbox.type = 'checkbox';
      allCheckbox.checked = allChecked;
      allCheckbox.style.marginRight = '8px';
      allCheckbox.tabIndex = -1;
      allDiv.appendChild(allCheckbox);
      allDiv.appendChild(document.createTextNode('All Areas'));
      allDiv.addEventListener('click', function(e) {
        e.stopPropagation();
        if (promptEditModeExit(e)) return;
        if (allChecked) {
          selectedCategories = new Set();
        } else {
          selectedCategories = new Set(categories);
        }
        // Clear all quick/custom filter highlights when manually changing categories
        if (typeof window.clearAllFilterButtonHighlights === 'function') {
          window.clearAllFilterButtonHighlights();
        }
        updateCategoryDropdown();
        updateCategoryDropdownLabel();
        saveToCache && saveToCache();
        renderTable(csvData);
        renderCategorySummary(csvData);
      });
      categoryDropdownList.appendChild(allDiv);
      // Divider
      const divider = document.createElement('div');
      divider.style.height = '1px';
      divider.style.background = '#e8ecf1';
      divider.style.margin = '4px 0';
      categoryDropdownList.appendChild(divider);
      // Category checkboxes
      categories.forEach(cat => {
        const div = document.createElement('div');
        div.style.padding = '2px 16px 2px 8px';
        div.style.cursor = 'pointer';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = cat;
        checkbox.checked = selectedCategories === null ? false : (selectedCategories.size === 0 || selectedCategories.has(cat));
        checkbox.style.marginRight = '8px';
        checkbox.tabIndex = -1;
        div.appendChild(checkbox);
        div.appendChild(document.createTextNode(cat));
        div.addEventListener('click', function(e) {
          e.stopPropagation();
          if (promptEditModeExit(e)) return;
          if (selectedCategories === null) {
            selectedCategories = new Set([cat]);
          } else if (selectedCategories.size === 0) {
            // All selected, so start a new set with just this one unchecked
            selectedCategories = new Set(categories.filter(c => c !== cat));
          } else if (selectedCategories.has(cat)) {
            selectedCategories.delete(cat);
            if (selectedCategories.size === 0) {
              selectedCategories = new Set();
            }
          } else {
            selectedCategories.add(cat);
            if (selectedCategories.size === categories.length) {
              selectedCategories = new Set();
            }
          }
          // Clear all quick/custom filter highlights when manually changing categories
          if (typeof window.clearAllFilterButtonHighlights === 'function') {
            window.clearAllFilterButtonHighlights();
          }
          updateCategoryDropdown();
          updateCategoryDropdownLabel();
          saveToCache && saveToCache();
          renderTable(csvData);
          renderCategorySummary(csvData);
        });
        categoryDropdownList.appendChild(div);
      });
    }

    function updateCategoryDropdownLabel() {
      const categories = getUniqueCategories();
      if (selectedCategories === null) {
        categoryDropdownLabel.textContent = 'None';
      } else if (selectedCategories.size === 0 || selectedCategories.size === categories.length) {
        categoryDropdownLabel.textContent = 'All Areas';
      } else if (selectedCategories.size === 1) {
        categoryDropdownLabel.textContent = Array.from(selectedCategories)[0];
      } else {
        categoryDropdownLabel.textContent = Array.from(selectedCategories).slice(0,2).join(', ') + (selectedCategories.size > 2 ? ` +${selectedCategories.size-2}` : '');
      }
    }

    if (categoryDropdownBtn && categoryDropdownList) {
      categoryDropdownBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        if (categoryDropdownList.style.display === 'none' || !categoryDropdownList.style.display) {
          updateCategoryDropdown();
          categoryDropdownList.style.display = 'block';
        } else {
          categoryDropdownList.style.display = 'none';
        }
      });
      // Close dropdown when clicking outside
      document.addEventListener('mousedown', function(e) {
        if (!categoryDropdownList.contains(e.target) && !categoryDropdownBtn.contains(e.target)) {
          categoryDropdownList.style.display = 'none';
        }
      });
    }

    // Keep label and dropdown in sync with data
    function syncCategoryDropdown() {
      updateCategoryDropdownLabel();
      if (categoryDropdownList.style.display === 'block') {
        updateCategoryDropdown();
      }
    }

    // When data changes, keep dropdown in sync
    const origRenderTable = window.renderTable;
    window.renderTable = function(data) {
      syncCategoryDropdown();
      origRenderTable.call(this, data);
    };

    // Initial population
    syncCategoryDropdown();
  // ==========================================
  // SIDEBAR RADIO LISTENERS (Execution, Scope, Age)
  // ==========================================

  // Attach sidebar EXECUTION TYPE radio listeners
  const execRadios = document.querySelectorAll('#prioritySidebar input[type="radio"][name="execType"]');
  execRadios.forEach(rb => {
    rb.addEventListener('change', function(e) {
      if (promptEditModeExit(e)) {
        e.target.checked = !e.target.checked;
        return;
      }
      if (this.checked) {
        filterExecType = this.value;
        // Clear all quick/custom filter highlights when manually changing filters
        if (typeof window.clearAllFilterButtonHighlights === 'function') {
          window.clearAllFilterButtonHighlights();
        }
        saveToCache();
        checkQuickFilterMatch();
        renderTable(csvData);
      }
    });
  });

  // Attach sidebar TEST SCOPE radio listeners
  const scopeRadios = document.querySelectorAll('#prioritySidebar input[type="radio"][name="testScope"]');
  scopeRadios.forEach(rb => {
    rb.addEventListener('change', function(e) {
      if (promptEditModeExit(e)) {
        e.target.checked = !e.target.checked;
        return;
      }
      if (this.checked) {
        filterTestScope = this.value;
        // Clear all quick/custom filter highlights when manually changing filters
        if (typeof window.clearAllFilterButtonHighlights === 'function') {
          window.clearAllFilterButtonHighlights();
        }
        saveToCache();
        checkQuickFilterMatch();
        renderTable(csvData);
      }
    });
  });

  // Attach sidebar AGE radio listeners
  const ageRadios = document.querySelectorAll('#prioritySidebar input[type="radio"][name="ageFilter"]');
  ageRadios.forEach(rb => {
    rb.addEventListener('change', function(e) {
      if (promptEditModeExit(e)) {
        e.target.checked = !e.target.checked;
        return;
      }
      if (this.checked) {
        filterAge = this.value;
        // Clear all quick/custom filter highlights when manually changing filters
        if (typeof window.clearAllFilterButtonHighlights === 'function') {
          window.clearAllFilterButtonHighlights();
        }
        saveToCache();
        checkQuickFilterMatch();
        renderTable(csvData);
      }
    });
  });

  // Attach sidebar CHECKBOX listeners (status, priority, etc)
  const allSidebarCheckboxes = document.querySelectorAll('#prioritySidebar input[type="checkbox"]');
  allSidebarCheckboxes.forEach(cb => {
    cb.addEventListener('change', function(e) {
      if (promptEditModeExit(e)) {
        e.target.checked = !e.target.checked;
        return;
      }
    }, true);
  });

  // On load, sync radio checked states
  execRadios.forEach(rb => { rb.checked = filterExecType === rb.value; });
  scopeRadios.forEach(rb => { rb.checked = filterTestScope === rb.value; });
  ageRadios.forEach(rb => { rb.checked = filterAge === rb.value; });

  // Priority filter button logic
  const priorityBtns = document.querySelectorAll('.priority-filter-btn');
  priorityBtns.forEach(btn => {
    btn.addEventListener('click', function(e) {
      if (promptEditModeExit(e)) return;
      const value = this.getAttribute('data-priority');
      if (filterPriority.has(value)) {
        filterPriority.delete(value);
        this.classList.remove('active');
      } else {
        filterPriority.add(value);
        this.classList.add('active');
      }
      // Clear all quick/custom filter highlights when manually changing filters
      if (typeof window.clearAllFilterButtonHighlights === 'function') {
        window.clearAllFilterButtonHighlights();
      }
      saveToCache();
      checkQuickFilterMatch();
      renderTable(csvData);
    });
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    // "/" key - Focus search box
    if (e.key === '/' && !isInputFocused()) {
      e.preventDefault();
      const searchBox = document.getElementById('testcaseNotesFilter');
      if (searchBox) {
        searchBox.focus();
        searchBox.select();
      }
    }
    
    // "Escape" key - Clear search and blur
    if (e.key === 'Escape') {
      const searchBox = document.getElementById('testcaseNotesFilter');
      if (searchBox && document.activeElement === searchBox) {
        searchBox.value = '';
        filterTestCase = '';
        searchBox.blur();
        saveToCache && saveToCache();
        renderTable(csvData);
      }
    }
    
    // "Ctrl+R" or "Cmd+R" key - Reset all filters (prevent default browser reload)
    if (e.key === 'r' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      const resetBtn = document.getElementById('resetFiltersBtn');
      if (resetBtn) resetBtn.click();
    }
    
    // "1-4" keys - Toggle priority filters (Critical, High, Medium, Low)
    if (['1', '2', '3', '4'].includes(e.key) && !isInputFocused()) {
      e.preventDefault();
      const priorityMap = { '1': 'C', '2': 'H', '3': 'M', '4': 'L' };
      const priority = priorityMap[e.key];
      
      // Toggle the priority in the set
      if (filterPriority.has(priority)) {
        filterPriority.delete(priority);
      } else {
        filterPriority.add(priority);
      }
      
      // Update button visual state
      const btn = document.querySelector(`.priority-filter-btn[data-priority="${priority}"]`);
      if (btn) {
        if (filterPriority.has(priority)) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      }
      
      saveToCache();
      renderTable(csvData);
    }
    
    // "p" key - Toggle Passed status filter
    if (e.key === 'p' && !isInputFocused()) {
      e.preventDefault();
      const checkbox = document.querySelector('#prioritySidebar input[type="checkbox"][name="status"][value="P"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      }
    }
    
    // "f" key - Toggle Failed status filter
    if (e.key === 'f' && !isInputFocused()) {
      e.preventDefault();
      const checkbox = document.querySelector('#prioritySidebar input[type="checkbox"][name="status"][value="F"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      }
    }
    
    // "n" key - Toggle Not Tested status filter
    if (e.key === 'n' && !isInputFocused()) {
      e.preventDefault();
      const checkbox = document.querySelector('#prioritySidebar input[type="checkbox"][name="status"][value="N"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      }
    }
    
    // "b" key - Toggle Blocked status filter
    if (e.key === 'b' && !isInputFocused()) {
      e.preventDefault();
      const checkbox = document.querySelector('#prioritySidebar input[type="checkbox"][name="status"][value="B"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      }
    }
    
    // "k" key - Toggle Known Issue status filter
    if (e.key === 'k' && !isInputFocused()) {
      e.preventDefault();
      const checkbox = document.querySelector('#prioritySidebar input[type="checkbox"][name="status"][value="K"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      }
    }
    
    // "s" key - Toggle Skipped status filter
    if (e.key === 's' && !isInputFocused()) {
      e.preventDefault();
      const checkbox = document.querySelector('#prioritySidebar input[type="checkbox"][name="status"][value="S"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      }
    }
    
    // "Shift+P" key - Toggle all/none Priority filters
    if (e.key === 'P' && e.shiftKey && !isInputFocused()) {
      e.preventDefault();
      // If all are selected, deselect all; otherwise select all
      const allSelected = filterPriority.size === 4;
      if (allSelected) {
        filterPriority.clear();
      } else {
        filterPriority = new Set(['C', 'H', 'M', 'L']);
      }
      // Update all button states
      document.querySelectorAll('.priority-filter-btn').forEach(btn => {
        const value = btn.getAttribute('data-priority');
        if (filterPriority.has(value)) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      saveToCache();
      renderTable(csvData);
    }
    
    // "Shift+S" key - Toggle all/none Status filters
    if (e.key === 'S' && e.shiftKey && !isInputFocused()) {
      e.preventDefault();
      // If all are selected, deselect all; otherwise select all
      const allSelected = filterStatus.size === 6;
      const statusCheckboxes = document.querySelectorAll('#prioritySidebar input[type="checkbox"][name="status"]');
      if (allSelected) {
        filterStatus.clear();
        statusCheckboxes.forEach(cb => cb.checked = false);
      } else {
        filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);
        statusCheckboxes.forEach(cb => cb.checked = true);
      }
      saveToCache();
      renderTable(csvData);
    }
    
    // "?" key - Show keyboard shortcuts modal
    if (e.key === '?' && !isInputFocused()) {
      e.preventDefault();
      toggleShortcutsModal();
    }
    // ESC key - Close keyboard shortcuts modal if open
    if (e.key === 'Escape' || e.key === 'Esc') {
      const modal = document.getElementById('shortcutsModal');
      if (modal && modal.classList.contains('active')) {
        toggleShortcutsModal();
      }
    }
  });
  
  // Keyboard shortcuts modal toggle
  function toggleShortcutsModal() {
    const modal = document.getElementById('shortcutsModal');
    if (modal) {
      modal.classList.toggle('active');
    }
  }
  
  // Keyboard shortcuts button
  const shortcutsBtn = document.getElementById('keyboardShortcutsBtn');
  if (shortcutsBtn) {
    shortcutsBtn.addEventListener('click', function() {
      toggleShortcutsModal();
    });
  }
  
  // Sort by criticality button
  const sortBtn = document.getElementById('sortByCriticalityBtn');
  if (sortBtn) {
    sortBtn.addEventListener('click', function() {
      sortByCriticality = !sortByCriticality;
      // Update button appearance
      if (sortByCriticality) {
        sortBtn.style.background = '#4a90e2';
        sortBtn.style.color = '#fff';
        sortBtn.style.borderColor = '#4a90e2';
        sortBtn.style.fontWeight = '600';
      } else {
        sortBtn.style.background = '#f8f9fa';
        sortBtn.style.color = '#6c7a8a';
        sortBtn.style.borderColor = '#d1d9e0';
        sortBtn.style.fontWeight = '500';
      }
      renderTable(csvData);
    });
  }
  
  // Jira filter button
  const jiraFilterBtn = document.getElementById('jiraFilterBtn');
  if (jiraFilterBtn) {
    jiraFilterBtn.addEventListener('click', function() {
      // Cycle through: all -> with-jira -> without-jira -> all
      if (jiraFilter === 'all') {
        jiraFilter = 'with-jira';
      } else if (jiraFilter === 'with-jira') {
        jiraFilter = 'without-jira';
      } else {
        jiraFilter = 'all';
      }
      console.log('Jira filter changed to:', jiraFilter);
      updateJiraFilterButton();
      renderTable(csvData);
    });
  }

  // New Test Run button - resets Passed to Not Tested, keeps other statuses
  const newTestRunBtn = document.getElementById('newTestRunBtn');
  if (newTestRunBtn) {
    newTestRunBtn.addEventListener('click', function() {
      if (!csvData.length) {
        alert('No test data loaded.');
        return;
      }

      // Count how many Passed tests will be reset
      const passedCount = csvData.filter(row => row.status === 'P').length;

      if (passedCount === 0) {
        alert('No Passed test cases to reset.');
        return;
      }

      // Confirm with user
      const confirmMsg = `This will reset ${passedCount} Passed test case${passedCount > 1 ? 's' : ''} to "Not Tested".\n\nFailed, Blocked, Known Issue, and Skipped statuses will be kept.\n\nProceed with new test run?`;
      if (!confirm(confirmMsg)) {
        return;
      }

      // Reset only Passed statuses to Not Tested
      csvData.forEach(row => {
        if (row.status === 'P') {
          row.status = 'N';
        }
      });

      saveToCache();
      renderTable(csvData);
      renderCategorySummary(csvData);

      // Show feedback
      alert(`New test run started!\n\n${passedCount} test case${passedCount > 1 ? 's' : ''} reset to "Not Tested".\n\nYou can now download the file with the fresh test run.`);
    });
  }

  // Clear New button - resets all 'New' age test cases to 'Old' after production verification
  const clearNewBtn = document.getElementById('clearNewBtn');
  if (clearNewBtn) {
    clearNewBtn.addEventListener('click', function() {
      if (!csvData.length) {
        alert('No test data loaded.');
        return;
      }

      // Count how many 'New' test cases will be reset
      const newCount = csvData.filter(row => row.age === 'N').length;

      if (newCount === 0) {
        alert('No "New" test cases to clear.');
        return;
      }

      // Confirm with user
      const confirmMsg = `This will change ${newCount} test case${newCount > 1 ? 's' : ''} from "New" to "Old".\n\nUse this after new functionality has been verified in production.\n\nProceed?`;
      if (!confirm(confirmMsg)) {
        return;
      }

      // Reset all 'New' to 'Old'
      csvData.forEach(row => {
        if (row.age === 'N') {
          row.age = 'O';
        }
      });

      saveToCache();
      renderTable(csvData);
      renderCategorySummary(csvData);

      // Show feedback
      alert(`Done!\n\n${newCount} test case${newCount > 1 ? 's' : ''} changed from "New" to "Old".\n\nYou can now download the updated file.`);
    });
  }

  // ==========================================
  // SPECIAL FILTERS (Pin, Question, Retest, etc.)
  // ==========================================

  // Helper function to reset all special filter buttons
  function resetSpecialFilters() {
    const buttons = [
      { btn: document.getElementById('pinFilterBtn'), filter: 'filterPinned' },
      { btn: document.getElementById('questionFilterBtn'), filter: 'filterQuestions' },
      { btn: document.getElementById('retestFilterBtn'), filter: 'filterRetest' },
      { btn: document.getElementById('pendingJiraFilterBtn'), filter: 'filterPendingJira' },
      { btn: document.getElementById('cleanupFilterBtn'), filter: 'filterCleanup' }
    ];
    
    buttons.forEach(item => {
      if (item.btn) {
        item.btn.style.background = '#ffffff';
        item.btn.style.color = '#6c7a8a';
        item.btn.style.borderColor = '#d1d9e0';
        item.btn.style.borderWidth = '1px';
        item.btn.style.boxShadow = 'none';
      }
      // Reset the filter variable
      if (item.filter === 'filterPinned') filterPinned = false;
      if (item.filter === 'filterQuestions') filterQuestions = false;
      if (item.filter === 'filterRetest') filterRetest = false;
      if (item.filter === 'filterPendingJira') filterPendingJira = false;
      if (item.filter === 'filterCleanup') filterCleanup = false;
    });
  }
  
  // Pin filter button
  const pinFilterBtn = document.getElementById('pinFilterBtn');
  if (pinFilterBtn) {
    pinFilterBtn.addEventListener('click', function() {
      // If already active, deactivate it
      if (filterPinned) {
        filterPinned = false;
        pinFilterBtn.style.background = '#ffffff';
        pinFilterBtn.style.color = '#6c7a8a';
        pinFilterBtn.style.borderColor = '#d1d9e0';
        pinFilterBtn.style.borderWidth = '1px';
        pinFilterBtn.style.boxShadow = 'none';
      } else {
        // Reset all other special filters first
        resetSpecialFilters();
        // Activate this filter
        filterPinned = true;
        pinFilterBtn.style.background = '#ffffff';
        pinFilterBtn.style.color = '#6c7a8a';
        pinFilterBtn.style.borderColor = '#1565c0';
        pinFilterBtn.style.borderWidth = '2px';
        pinFilterBtn.style.boxShadow = '0 0 0 2px rgba(21, 101, 192, 0.2)';
      }
      renderTable(csvData);
    });
  }
  
  // Question filter button
  const questionFilterBtn = document.getElementById('questionFilterBtn');
  if (questionFilterBtn) {
    questionFilterBtn.addEventListener('click', function() {
      // If already active, deactivate it
      if (filterQuestions) {
        filterQuestions = false;
        questionFilterBtn.style.background = '#ffffff';
        questionFilterBtn.style.color = '#6c7a8a';
        questionFilterBtn.style.borderColor = '#d1d9e0';
        questionFilterBtn.style.borderWidth = '1px';
        questionFilterBtn.style.boxShadow = 'none';
      } else {
        // Reset all other special filters first
        resetSpecialFilters();
        // Activate this filter
        filterQuestions = true;
        questionFilterBtn.style.background = '#ffffff';
        questionFilterBtn.style.color = '#6c7a8a';
        questionFilterBtn.style.borderColor = '#fbc02d';
        questionFilterBtn.style.borderWidth = '2px';
        questionFilterBtn.style.boxShadow = '0 0 0 2px rgba(251, 192, 45, 0.2)';
      }
      renderTable(csvData);
    });
  }
  
  // Pending Jira filter button
  const pendingJiraFilterBtn = document.getElementById('pendingJiraFilterBtn');
  if (pendingJiraFilterBtn) {
    pendingJiraFilterBtn.addEventListener('click', function() {
      // If already active, deactivate it
      if (filterPendingJira) {
        filterPendingJira = false;
        pendingJiraFilterBtn.style.background = '#ffffff';
        pendingJiraFilterBtn.style.color = '#6c7a8a';
        pendingJiraFilterBtn.style.borderColor = '#d1d9e0';
        pendingJiraFilterBtn.style.borderWidth = '1px';
        pendingJiraFilterBtn.style.boxShadow = 'none';
      } else {
        // Reset all other special filters first
        resetSpecialFilters();
        // Activate this filter
        filterPendingJira = true;
        pendingJiraFilterBtn.style.background = '#ffffff';
        pendingJiraFilterBtn.style.color = '#6c7a8a';
        pendingJiraFilterBtn.style.borderColor = '#8e24aa';
        pendingJiraFilterBtn.style.borderWidth = '2px';
        pendingJiraFilterBtn.style.boxShadow = '0 0 0 2px rgba(142, 36, 170, 0.2)';
      }
      renderTable(csvData);
    });
  }
  
  // Cleanup filter button
  const cleanupFilterBtn = document.getElementById('cleanupFilterBtn');
  if (cleanupFilterBtn) {
    cleanupFilterBtn.addEventListener('click', function() {
      // If already active, deactivate it
      if (filterCleanup) {
        filterCleanup = false;
        cleanupFilterBtn.style.background = '#ffffff';
        cleanupFilterBtn.style.color = '#6c7a8a';
        cleanupFilterBtn.style.borderColor = '#d1d9e0';
        cleanupFilterBtn.style.borderWidth = '1px';
        cleanupFilterBtn.style.boxShadow = 'none';
      } else {
        // Reset all other special filters first
        resetSpecialFilters();
        // Activate this filter
        filterCleanup = true;
        cleanupFilterBtn.style.background = '#ffffff';
        cleanupFilterBtn.style.color = '#6c7a8a';
        cleanupFilterBtn.style.borderColor = '#00838f';
        cleanupFilterBtn.style.borderWidth = '2px';
        cleanupFilterBtn.style.boxShadow = '0 0 0 2px rgba(0, 131, 143, 0.2)';
      }
      renderTable(csvData);
    });
  }
  
  // Retest filter button
  const retestFilterBtn = document.getElementById('retestFilterBtn');
  if (retestFilterBtn) {
    retestFilterBtn.addEventListener('click', function() {
      // If already active, deactivate it
      if (filterRetest) {
        filterRetest = false;
        retestFilterBtn.style.background = '#ffffff';
        retestFilterBtn.style.color = '#6c7a8a';
        retestFilterBtn.style.borderColor = '#d1d9e0';
        retestFilterBtn.style.borderWidth = '1px';
        retestFilterBtn.style.boxShadow = 'none';
      } else {
        // Reset all other special filters first
        resetSpecialFilters();
        // Activate this filter
        filterRetest = true;
        retestFilterBtn.style.background = '#ffffff';
        retestFilterBtn.style.color = '#6c7a8a';
        retestFilterBtn.style.borderColor = '#ff6b35';
        retestFilterBtn.style.borderWidth = '2px';
        retestFilterBtn.style.boxShadow = '0 0 0 2px rgba(255, 107, 53, 0.2)';
      }
      renderTable(csvData);
    });
  }
  
  // Jira header click for sorting
  const jiraHeaderCol = document.getElementById('jiraHeaderCol');
  if (jiraHeaderCol) {
    jiraHeaderCol.addEventListener('click', function() {
      // Cycle through: default -> with-first -> without-first -> default
      if (jiraSortOrder === 'default') {
        jiraSortOrder = 'with-first';
      } else if (jiraSortOrder === 'with-first') {
        jiraSortOrder = 'without-first';
      } else {
        jiraSortOrder = 'default';
      }
      console.log('Jira sort order changed to:', jiraSortOrder);
      updateJiraSortIcon();
      renderTable(csvData);
    });
  }
  
  // Close modal button
  const closeModalBtn = document.getElementById('closeShortcutsModal');
  if (closeModalBtn) {
    closeModalBtn.addEventListener('click', function() {
      toggleShortcutsModal();
    });
  }
  
  // Close modal when clicking outside
  const modal = document.getElementById('shortcutsModal');
  if (modal) {
    modal.addEventListener('click', function(e) {
      if (e.target === modal) {
        toggleShortcutsModal();
      }
    });
  }
  
  // ==========================================
  // QUICK FILTERS & CUSTOM FILTERS
  // ==========================================

  // Quick Filters functionality (both old and sidebar buttons)
  const quickFilterBtns = document.querySelectorAll('.quick-filter-btn, .quick-filter-btn-sidebar');

  quickFilterBtns.forEach(btn => {
    btn.addEventListener('click', function(e) {
      if (promptEditModeExit(e)) return;
      const filterType = this.getAttribute('data-filter');
      // Check if clicking the same active filter
      const wasActive = this.classList.contains('active');

      // Remove active class from ALL filter buttons (quick filters AND custom filters)
      clearAllFilterButtonHighlights();

      if (wasActive) {
        // Clicking the same filter again - deactivate and reset to defaults
        resetFiltersToDefault();
      } else {
        // Apply the specific filter configuration and highlight this button
        this.classList.add('active');
        applyQuickFilter(filterType);
      }
      saveToCache();
      renderTable(csvData);
    });
  });

  // Helper function to clear all filter button highlights
  function clearAllFilterButtonHighlights() {
    document.querySelectorAll('.quick-filter-btn, .quick-filter-btn-sidebar, .custom-filter-btn').forEach(b => b.classList.remove('active'));
  }

  // Expose globally
  window.clearAllFilterButtonHighlights = clearAllFilterButtonHighlights;
  
  function applyQuickFilter(filterType) {
    switch(filterType) {
      case 'show-all':
        // Reset to defaults - show all
        filterPriority = new Set(['C', 'H', 'M', 'L']);
        filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);
        filterTestScope = 'R';
        filterExecType = 'Both';
        filterAge = 'Both';
        updateFilterUI();
        break;
      case 'issues':
        // Priority: Critical, High, Medium, Low + Status: Failed, Blocked, Known Issue
        filterPriority = new Set(['C', 'H', 'M', 'L']);
        filterStatus = new Set(['F', 'B', 'K']);
        filterTestScope = 'R'; // Regression
        filterExecType = 'Both';
        filterAge = 'Both';
        updateFilterUI();
        break;

      case 'critical-issues':
        // Priority: Critical + Status: Failed, Blocked, Known Issue
        filterPriority = new Set(['C']);
        filterStatus = new Set(['F', 'B', 'K']);
        filterTestScope = 'R';
        filterExecType = 'Both';
        filterAge = 'Both';
        updateFilterUI();
        break;

      case 'new-features':
        // Age: New features only (across all scopes)
        filterAge = 'N';
        filterTestScope = 'R'; // Regression (show all scopes)
        filterPriority = new Set(['C', 'H', 'M', 'L']); // All priorities
        filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']); // All statuses
        filterExecType = 'Both';
        updateFilterUI();
        break;

      case 'not-tested':
        // Status: Not Tested only
        filterStatus = new Set(['N']);
        filterPriority = new Set(['C', 'H', 'M', 'L']); // All priorities
        filterTestScope = 'R';
        filterExecType = 'Both';
        filterAge = 'Both';
        updateFilterUI();
        break;

      case 'failed-blocked':
        // Status: Failed, Blocked
        filterStatus = new Set(['F', 'B']);
        filterPriority = new Set(['C', 'H', 'M', 'L']); // All priorities
        filterTestScope = 'R';
        filterExecType = 'Both';
        filterAge = 'Both';
        updateFilterUI();
        break;

      case 'smoke':
        // Scope: Smoke only
        filterTestScope = 'S';
        filterPriority = new Set(['C', 'H', 'M', 'L']); // All priorities
        filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']); // All statuses
        filterExecType = 'Both';
        filterAge = 'Both';
        updateFilterUI();
        break;

      case 'automated':
        // Execution: Automated only
        filterExecType = 'A';
        filterPriority = new Set(['C', 'H', 'M', 'L']); // All priorities
        filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']); // All statuses
        filterAge = 'Both';
        filterTestScope = 'R';
        updateFilterUI();
        break;
    }
  }
  
  function updateFilterUI() {
    // Update priority buttons
    document.querySelectorAll('.priority-filter-btn').forEach(btn => {
      const value = btn.getAttribute('data-priority');
      if (filterPriority.has(value)) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    // Update status checkboxes
    document.querySelectorAll('#prioritySidebar input[type="checkbox"][name="status"]').forEach(cb => {
      cb.checked = filterStatus.has(cb.value);
    });

    // Update scope radio buttons
    document.querySelectorAll('#prioritySidebar input[type="radio"][name="testScope"]').forEach(rb => {
      rb.checked = filterTestScope === rb.value;
    });

    // Update age radio buttons
    document.querySelectorAll('#prioritySidebar input[type="radio"][name="ageFilter"]').forEach(rb => {
      rb.checked = filterAge === rb.value;
    });

    // Update execution type radio buttons
    document.querySelectorAll('#prioritySidebar input[type="radio"][name="execType"]').forEach(rb => {
      rb.checked = filterExecType === rb.value;
    });

    // Check if filters match any quick filter preset
    checkQuickFilterMatch();
  }
  
  function resetFiltersToDefault() {
    filterPriority = new Set(['C', 'H', 'M', 'L']);
    filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);
    filterTestScope = 'R';
    filterExecType = 'Both';
    filterAge = 'Both';
    jiraFilter = 'all';
    filterPinned = false;
    filterQuestions = false;
    filterRetest = false;
    filterPendingJira = false;
    filterCleanup = false;
    selectedCategories = new Set();
    if (typeof updateJiraFilterButton === 'function') updateJiraFilterButton();
    if (typeof resetSpecialFilters === 'function') resetSpecialFilters();
    updateFilterUI();
  }

  // ==========================================
  // CUSTOM FILTERS FUNCTIONALITY
  // ==========================================

  // Save current filter as a custom filter
  function saveCurrentFilter() {
    // Check if current filter is already a preset (not custom)
    const matchedPreset = getMatchedQuickFilter();
    if (matchedPreset && matchedPreset !== 'custom') {
      alert('This is already a built-in quick filter. Custom filters are for saving unique filter combinations.');
      return;
    }

    // Prompt for filter name
    const filterName = prompt('Enter a name for this custom filter:', '');
    if (!filterName || !filterName.trim()) {
      return; // User cancelled or entered empty name
    }

    // Create the custom filter object
    const newFilter = {
      id: Date.now().toString(),
      name: filterName.trim(),
      config: {
        priority: Array.from(filterPriority),
        status: Array.from(filterStatus),
        scope: filterTestScope,
        execType: filterExecType,
        age: filterAge,
        categories: Array.from(selectedCategories)
      }
    };

    // Add to custom filters array
    customFilters.push(newFilter);

    // Save to cache and render
    saveToCache();
    renderCustomFilters();
  }

  // Get which quick filter matches current state (returns null if none)
  function getMatchedQuickFilter() {
    const defaultPriority = new Set(['C', 'H', 'M', 'L']);
    const defaultStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);

    // If specific categories are selected (not "All Areas"), this is NOT a built-in quick filter
    // Built-in quick filters always apply to all areas, so having specific categories = custom filter
    if (selectedCategories && selectedCategories.size > 0) {
      return null; // Allow saving as custom filter
    }

    // Check show-all
    if (areSetsEqual(filterPriority, defaultPriority) &&
        areSetsEqual(filterStatus, defaultStatus) &&
        filterTestScope === 'R' &&
        filterExecType === 'Both' &&
        filterAge === 'Both') {
      return 'show-all';
    }

    // Check issues
    if (areSetsEqual(filterPriority, defaultPriority) &&
        areSetsEqual(filterStatus, new Set(['F', 'B', 'K'])) &&
        filterTestScope === 'R' &&
        filterExecType === 'Both' &&
        filterAge === 'Both') {
      return 'issues';
    }

    // Check critical-issues
    if (areSetsEqual(filterPriority, new Set(['C'])) &&
        areSetsEqual(filterStatus, new Set(['F', 'B', 'K'])) &&
        filterTestScope === 'R' &&
        filterExecType === 'Both' &&
        filterAge === 'Both') {
      return 'critical-issues';
    }

    // Check new-features
    if (areSetsEqual(filterPriority, defaultPriority) &&
        areSetsEqual(filterStatus, defaultStatus) &&
        filterTestScope === 'R' &&
        filterExecType === 'Both' &&
        filterAge === 'N') {
      return 'new-features';
    }

    // Check not-tested
    if (areSetsEqual(filterPriority, defaultPriority) &&
        areSetsEqual(filterStatus, new Set(['N'])) &&
        filterTestScope === 'R' &&
        filterExecType === 'Both' &&
        filterAge === 'Both') {
      return 'not-tested';
    }

    // Check failed-blocked
    if (areSetsEqual(filterPriority, defaultPriority) &&
        areSetsEqual(filterStatus, new Set(['F', 'B'])) &&
        filterTestScope === 'R' &&
        filterExecType === 'Both' &&
        filterAge === 'Both') {
      return 'failed-blocked';
    }

    // Check smoke
    if (areSetsEqual(filterPriority, defaultPriority) &&
        areSetsEqual(filterStatus, defaultStatus) &&
        filterTestScope === 'S' &&
        filterExecType === 'Both' &&
        filterAge === 'Both') {
      return 'smoke';
    }

    // Check automated
    if (areSetsEqual(filterPriority, defaultPriority) &&
        areSetsEqual(filterStatus, defaultStatus) &&
        filterTestScope === 'R' &&
        filterExecType === 'A' &&
        filterAge === 'Both') {
      return 'automated';
    }

    return null; // No preset matches - this is a custom filter combination
  }

  // Render custom filters in the sidebar
  function renderCustomFilters() {
    const section = document.getElementById('customFiltersSection');
    const list = document.getElementById('customFiltersList');

    if (!section || !list) return;

    if (customFilters.length === 0) {
      section.style.display = 'none';
      return;
    }

    section.style.display = 'block';
    list.innerHTML = '';

    customFilters.forEach(filter => {
      const btn = document.createElement('button');
      btn.className = 'custom-filter-btn';
      btn.setAttribute('data-filter-id', filter.id);
      btn.title = `Apply filter: ${filter.name}`;

      btn.innerHTML = `
        <span class="qf-icon">‚öôÔ∏è</span>
        <span class="custom-filter-name">${escapeHtml(filter.name)}</span>
        <span class="custom-filter-delete" title="Delete this filter">√ó</span>
      `;

      // Click handler to apply the filter
      btn.addEventListener('click', function(e) {
        // Check if delete button was clicked
        if (e.target.classList.contains('custom-filter-delete')) {
          e.stopPropagation();
          deleteCustomFilter(filter.id);
          return;
        }

        // Check if already active - if so, reset to defaults
        const wasActive = this.classList.contains('active');

        // Remove active from all quick filter buttons
        document.querySelectorAll('.quick-filter-btn, .quick-filter-btn-sidebar, .custom-filter-btn').forEach(b => b.classList.remove('active'));

        if (wasActive) {
          resetFiltersToDefault();
        } else {
          this.classList.add('active');
          applyCustomFilter(filter);
        }

        saveToCache();
        renderTable(csvData);
      });

      list.appendChild(btn);
    });
  }

  // Apply a custom filter
  function applyCustomFilter(filter) {
    const config = filter.config;

    filterPriority = new Set(config.priority || ['C', 'H', 'M', 'L']);
    filterStatus = new Set(config.status || ['N', 'P', 'F', 'B', 'K', 'S']);
    filterTestScope = config.scope || 'R';
    filterExecType = config.execType || 'Both';
    filterAge = config.age || 'Both';

    // Apply categories - if saved, use them; otherwise reset to all
    if (config.categories && config.categories.length > 0) {
      selectedCategories = new Set(config.categories);
    } else {
      selectedCategories = new Set(); // All categories
    }
    // Update category dropdown UI
    if (typeof updateCategoryDropdown === 'function') {
      updateCategoryDropdown();
    }
    if (typeof updateCategoryDropdownLabel === 'function') {
      updateCategoryDropdownLabel();
    }

    updateFilterUI();
  }

  // Delete a custom filter
  function deleteCustomFilter(filterId) {
    if (!confirm('Are you sure you want to delete this custom filter?')) {
      return;
    }

    customFilters = customFilters.filter(f => f.id !== filterId);
    saveToCache();
    renderCustomFilters();
  }

  // Expose functions globally for use outside this scope
  window.renderCustomFilters = renderCustomFilters;
  window.saveCurrentFilter = saveCurrentFilter;

  // Save Custom Filter button handler
  const saveCustomFilterBtn = document.getElementById('saveCustomFilterBtn');
  if (saveCustomFilterBtn) {
    saveCustomFilterBtn.addEventListener('click', function() {
      saveCurrentFilter();
    });
  }

  // Helper function to check if an input/textarea is focused
  function isInputFocused() {
    const activeEl = document.activeElement;
    return activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);
  }

  // On load, sync button active state
  priorityBtns.forEach(btn => {
    const value = btn.getAttribute('data-priority');
    if (filterPriority.has(value)) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
});
// NOTE: Sidebar TEST SCOPE and AGE radio listeners are now attached in the main DOMContentLoaded block around line 1209

/* ==========================================
   STATE MANAGEMENT - Global Variables
   ========================================== */

let csvData = [];
let filterExecType = 'Both';
let filterTestScope = 'R'; // Default to Regression
let filterAge = 'Both'; // Both, N (New), O (Old/Established)
let filterPriority = new Set(['C', 'H', 'M', 'L']); // Default: show all priorities
let filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']); // Default: show all statuses
let filterTestCase = ''; // Test case keyword filter
let filterPinned = false; // Filter to show only pinned test cases (marked with * prefix)
let filterQuestions = false; // Filter to show only test cases with questions (marked with ? prefix)
let filterRetest = false; // Filter to show only test cases needing retest after dev fix (marked with @ prefix)
let filterPendingJira = false; // Filter to show only test cases pending Jira ticket creation (marked with ! prefix)
let filterCleanup = false; // Filter to show only test cases needing cleanup/editing (marked with ~ prefix)
let collapsedCategories = new Set(); // Track which categories are collapsed
let selectedCategories = new Set(); // Track which categories are selected for metrics filtering (empty = all selected)
let currentChartIndex = 0; // Track which chart is currently shown in the carousel

/* ==========================================
   UTILITY FUNCTIONS
   ========================================== */

// Get unique categories from CSV data (preserves order from file)
function getUniqueCategories() {
  const categories = new Set();
  csvData.forEach(row => {
    if (row.category) {
      categories.add(row.category);
    }
  });
  // Return in file order (Set preserves insertion order), not alphabetical
  return Array.from(categories);
}

/* ==========================================
   DATA PERSISTENCE - LocalStorage
   ========================================== */

// LocalStorage keys
const STORAGE_KEY_DATA = 'testcases_data';
const STORAGE_KEY_EXEC_FILTER = 'testcases_exec_filter';
const STORAGE_KEY_SCOPE_FILTER = 'testcases_scope_filter';
const STORAGE_KEY_PRIORITY_FILTER = 'testcases_priority_filter';
const STORAGE_KEY_TESTING_NOTES = 'testcases_testing_notes';
const STORAGE_KEY_FILENAME = 'testcases_filename';
const STORAGE_KEY_ENVIRONMENT = 'testcases_environment';
const STORAGE_KEY_FILENAME_TEAM = 'testcases_filename_team';
const STORAGE_KEY_FILENAME_ENV = 'testcases_filename_env';
const STORAGE_KEY_FILENAME_RELEASE = 'testcases_filename_release';
const STORAGE_KEY_FILENAME_NOTES = 'testcases_filename_notes';
const STORAGE_KEY_CUSTOM_FILTERS = 'testcases_custom_filters';
const STORAGE_KEY_FILE_CONFIG = 'testcases_file_config';

// Save data to localStorage
// Clean up priorities for non-bug statuses (Priority only applies to Failed/Blocked)
function cleanupPrioritiesForNonBugs() {
  let cleaned = 0;
  csvData.forEach(row => {
    // Only Failed (F) and Blocked (B) should have priorities
    if (row.status !== 'F' && row.status !== 'B') {
      if (row.priority && row.priority !== '') {
        row.priority = '';
        cleaned++;
      }
    }
  });
  return cleaned;
}

function saveToCache() {
  try {
    // Clean up priorities before saving - Priority only applies to bugs (Failed/Blocked)
    cleanupPrioritiesForNonBugs();
    localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(csvData));
    localStorage.setItem(STORAGE_KEY_EXEC_FILTER, filterExecType);
    localStorage.setItem(STORAGE_KEY_SCOPE_FILTER, filterTestScope);
    localStorage.setItem(STORAGE_KEY_PRIORITY_FILTER, JSON.stringify(Array.from(filterPriority)));
    
    // Save testing notes
    const notesTextarea = document.getElementById('testingNotesTextarea');
    if (notesTextarea) {
      testingNotes = notesTextarea.value;
      localStorage.setItem(STORAGE_KEY_TESTING_NOTES, testingNotes);
    }
    
    // Save filename
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadBtnText = uploadBtn ? uploadBtn.querySelector('.upload-btn-text') : null;
    if (uploadBtnText && uploadBtnText.textContent !== 'Choose File (.csv or .tqt)') {
      localStorage.setItem(STORAGE_KEY_FILENAME, uploadBtnText.textContent);
    }

    // Save environment dropdown
    const envDropdown = document.getElementById('envDropdown');
    if (envDropdown) {
      localStorage.setItem(STORAGE_KEY_ENVIRONMENT, envDropdown.value);
    }

    // Save filename input fields
    const teamInput = document.getElementById('teamInput');
    const envInput = document.getElementById('envInput');
    const releaseInput = document.getElementById('releaseInput');
    const notesInput = document.getElementById('notesInput');
    if (teamInput) localStorage.setItem(STORAGE_KEY_FILENAME_TEAM, teamInput.value);
    if (envInput) localStorage.setItem(STORAGE_KEY_FILENAME_ENV, envInput.value);
    if (releaseInput) localStorage.setItem(STORAGE_KEY_FILENAME_RELEASE, releaseInput.value);
    if (notesInput) localStorage.setItem(STORAGE_KEY_FILENAME_NOTES, notesInput.value);

    // Save custom filters
    localStorage.setItem(STORAGE_KEY_CUSTOM_FILTERS, JSON.stringify(customFilters));

    // Save file config (App-Name, Projects, etc.)
    localStorage.setItem(STORAGE_KEY_FILE_CONFIG, JSON.stringify(fileConfig));
  } catch (e) {
    console.error('Failed to save to localStorage:', e);
  }
}

// Load data from localStorage
function loadFromCache() {
  try {
    const savedData = localStorage.getItem(STORAGE_KEY_DATA);
    const savedExecFilter = localStorage.getItem(STORAGE_KEY_EXEC_FILTER);
    const savedScopeFilter = localStorage.getItem(STORAGE_KEY_SCOPE_FILTER);
    const savedPriorityFilter = localStorage.getItem(STORAGE_KEY_PRIORITY_FILTER);
    const savedTestingNotes = localStorage.getItem(STORAGE_KEY_TESTING_NOTES);
    const savedFilename = localStorage.getItem(STORAGE_KEY_FILENAME);
    const savedEnvironment = localStorage.getItem(STORAGE_KEY_ENVIRONMENT);
    const savedTeam = localStorage.getItem(STORAGE_KEY_FILENAME_TEAM);
    const savedEnv = localStorage.getItem(STORAGE_KEY_FILENAME_ENV);
    const savedRelease = localStorage.getItem(STORAGE_KEY_FILENAME_RELEASE);
    const savedNotes = localStorage.getItem(STORAGE_KEY_FILENAME_NOTES);
    
    // Load environment dropdown
    const envDropdown = document.getElementById('envDropdown');
    if (envDropdown && savedEnvironment) {
      envDropdown.value = savedEnvironment;
    }

    // Load filename input fields
    const teamInput = document.getElementById('teamInput');
    const envInput = document.getElementById('envInput');
    const releaseInput = document.getElementById('releaseInput');
    const notesInput = document.getElementById('notesInput');
    if (teamInput && savedTeam) teamInput.value = savedTeam;
    if (envInput && savedEnv) envInput.value = savedEnv;
    if (releaseInput && savedRelease) releaseInput.value = savedRelease;
    if (notesInput && savedNotes) notesInput.value = savedNotes;
    
    // Restore testing notes
    const notesTextarea = document.getElementById('testingNotesTextarea');
    if (notesTextarea && savedTestingNotes) {
      testingNotes = savedTestingNotes;
      notesTextarea.value = savedTestingNotes;
    }
    
    // Enable Tab key in testing notes textarea
    if (notesTextarea) {
      notesTextarea.addEventListener('keydown', function(e) {
        if (e.key === 'Tab') {
          e.preventDefault();
          const start = this.selectionStart;
          const end = this.selectionEnd;
          const value = this.value;
          
          // Insert 2 spaces instead of tab character
          this.value = value.substring(0, start) + '  ' + value.substring(end);
          
          // Move cursor after the inserted spaces
          this.selectionStart = this.selectionEnd = start + 2;
          
          // Trigger input event to save the change
          this.dispatchEvent(new Event('input', { bubbles: true }));
        }
      });
    }
    
    // (Removed nested DOMContentLoaded. Sidebar STATUS checkbox listeners are attached in the main DOMContentLoaded handler below.)
    
    if (savedData) {
      csvData = JSON.parse(savedData);
      // Clean up priorities for non-bug statuses on load
      const cleanedCount = cleanupPrioritiesForNonBugs();
      if (cleanedCount > 0) {
        console.log(`Cleaned ${cleanedCount} priorities from non-bug statuses`);
        // Save the cleaned data back to cache
        localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(csvData));
      }
      console.log('CSV data loaded. Sample rows:', csvData.slice(0, 3));
      console.log('First row jira field:', csvData[0]?.jira);
      renderTable(csvData);
    }
    
    if (savedExecFilter) {
      filterExecType = savedExecFilter;
      document.querySelector(`input[name="execType"][value="${filterExecType}"]`).checked = true;
    }
    
    if (savedScopeFilter) {
      filterTestScope = savedScopeFilter;
      document.querySelector(`input[name="testScope"][value="${filterTestScope}"]`).checked = true;
    }
    
    if (savedPriorityFilter) {
      try {
        const priorityArray = JSON.parse(savedPriorityFilter);
        filterPriority = new Set(priorityArray);
        // Update the button active state
        document.querySelectorAll('.priority-filter-btn').forEach(btn => {
          const value = btn.getAttribute('data-priority');
          if (filterPriority.has(value)) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      } catch (e) {
        // If parsing fails, reset to default
        filterPriority = new Set(['C', 'H', 'M', 'L']);
      }
    }
    
    // Load and display filename
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadBtnText = uploadBtn ? uploadBtn.querySelector('.upload-btn-text') : null;
    if (savedFilename && uploadBtnText) {
      uploadBtnText.textContent = savedFilename;
      uploadBtn.classList.add('has-file');
    }

    // Load custom filters
    const savedCustomFilters = localStorage.getItem(STORAGE_KEY_CUSTOM_FILTERS);
    if (savedCustomFilters) {
      try {
        customFilters = JSON.parse(savedCustomFilters);
        // renderCustomFilters will be called after DOMContentLoaded completes
      } catch (e) {
        customFilters = [];
      }
    }

    // Load file config and apply settings
    const savedFileConfig = localStorage.getItem(STORAGE_KEY_FILE_CONFIG);
    if (savedFileConfig) {
      try {
        fileConfig = JSON.parse(savedFileConfig);
        applyConfigSettings(fileConfig);
      } catch (e) {
        fileConfig = {};
      }
    }
  } catch (e) {
    console.error('Failed to load from localStorage:', e);
  }
}

// Helper to escape HTML for safe rendering
function escapeHtml(text) {
  if (!text) return '';
  return text.replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

/* ==========================================
   RENDERING FUNCTIONS - UI Updates
   ========================================== */

function renderCategorySummary(data) {
  const summaryDiv = document.getElementById('categorySummary');
  const metricsDiv = document.getElementById('metricsOverview');
  
  if (!data.length) {
    if (filterStatus.size === 0 || filterPriority.size === 0) {
      metricsDiv.innerHTML = `<div style="text-align: center; padding: 40px 20px; color: #868e96;"><div style="font-size: 48px; margin-bottom: 16px; opacity: 0.3;">‚ö†</div><div style="font-size: 16px; font-weight: 600; color: #6c757d; margin-bottom: 8px;">No Filters Selected</div><div style="font-size: 13px;">Please select at least one status and one priority filter to view test metrics.</div></div>`;
      summaryDiv.innerHTML = `<div style="text-align: center; padding: 24px 16px; color: #868e96; background: #fafbfc; border: 1px solid #e8ecf1; border-radius: 8px;"><div style="font-size: 13px; font-weight: 500;">No filters active</div></div>`;
      return;
    } else {
      summaryDiv.innerHTML = '';
      metricsDiv.innerHTML = '';
      return;
    }
  }
  
  // Group by category for percentages and failed cases
  const catMap = {};
  const catData = {}; // Store actual test case objects by category
  const failedMap = {};
  const blockedMap = {};
  const knownMap = {};
  
  // Overall metrics
  let totalTests = 0;
  let totalNotTested = 0;
  let totalPassed = 0;
  let totalFailed = 0;
  let totalBlocked = 0;
  let totalKnown = 0;
  let totalSkipped = 0;
  
  // Priority counts
  let priorityCritical = 0;
  let priorityHigh = 0;
  let priorityMedium = 0;
  let priorityLow = 0;
  
  data.forEach(row => {
    const cat = row.category || 'Uncategorized';
    if (!catMap[cat]) catMap[cat] = { total: 0, passed: 0, failed: 0, blocked: 0, known: 0, skipped: 0, notTested: 0 };
    if (!catData[cat]) catData[cat] = [];
    
    catMap[cat].total++;
    catData[cat].push(row); // Store the actual test case object
    
    // Only count towards overall metrics if category is selected (or if no categories are selected, count all)
    const shouldCountInMetrics = selectedCategories.size === 0 || selectedCategories.has(cat);
    
    if (shouldCountInMetrics) {
      totalTests++;
    }
    
    if (row.status === 'N' || !row.status) {
      catMap[cat].notTested++;
      if (shouldCountInMetrics) totalNotTested++;
    }
    if (row.status === 'P') {
      catMap[cat].passed++;
      if (shouldCountInMetrics) totalPassed++;
    }
    if (row.status === 'F') {
      catMap[cat].failed++;
      if (shouldCountInMetrics) totalFailed++;
      if (!failedMap[cat]) failedMap[cat] = [];
      failedMap[cat].push(row.testcase);
    }
    if (row.status === 'B') {
      catMap[cat].blocked++;
      if (shouldCountInMetrics) totalBlocked++;
      if (!blockedMap[cat]) blockedMap[cat] = [];
      blockedMap[cat].push(row.testcase);
    }
    if (row.status === 'K') {
      catMap[cat].known++;
      if (shouldCountInMetrics) totalKnown++;
      if (!knownMap[cat]) knownMap[cat] = [];
      knownMap[cat].push(row.testcase);
    }
    if (row.status === 'S') {
      catMap[cat].skipped++;
      if (shouldCountInMetrics) totalSkipped++;
    }
    
    // Count priorities - ONLY for bug statuses (Failed/Blocked)
    // Priority represents bug severity, not test case importance
    if (shouldCountInMetrics && (row.status === 'F' || row.status === 'B')) {
      if (row.priority === 'C') priorityCritical++;
      else if (row.priority === 'H') priorityHigh++;
      else if (row.priority === 'M') priorityMedium++;
      else if (row.priority === 'L') priorityLow++;
    }
  });
  
  // Calculate overall progress
  const totalTested = totalPassed + totalFailed + totalBlocked + totalKnown + totalSkipped;

  // Build tooltip content for all status types
  let totalTestsTooltip = '';
  let totalTestsCopyText = '';
  let notTestedTooltip = '';
  let passedTooltip = '';
  let failedTooltip = '';
  let blockedTooltip = '';
  let knownTooltip = '';
  let notTestedCopyText = '';
  let passedCopyText = '';
  let failedCopyText = '';
  let blockedCopyText = '';
  let knownCopyText = '';

  // Tooltip for TOTAL TESTS
  if (totalTests > 0) {
    totalTestsTooltip = '<div class="metric-tooltip-header"><div class="metric-tooltip-title">All Test Cases</div><button class="metric-tooltip-copy" data-type="total">Copy</button></div>';
    totalTestsCopyText = 'All Test Cases:\n\n';
    // Group by category for display
    const allByCat = {};
    data.forEach(row => {
      const cat = row.category || 'Uncategorized';
      if (!allByCat[cat]) allByCat[cat] = [];
      allByCat[cat].push(row);
    });
    Object.keys(allByCat).sort().forEach(cat => {
      const catCount = allByCat[cat].length;
      totalTestsTooltip += `<div class=\"metric-tooltip-category-header\">${escapeHtml(cat)} (${catCount})</div>`;
      totalTestsCopyText += `${cat} (${catCount}):\n`;
      allByCat[cat].forEach(row => {
        let notes = '';
        let copyNotes = '';
        if (row.notes) {
          const noteItems = row.notes.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            notes = '<span class="metric-tooltip-notes">' + noteItems.map(n => escapeHtml(n)).join('; ') + '</span>';
            copyNotes = ' (' + noteItems.join('; ') + ')';
          }
        }
        totalTestsTooltip += `<div class=\"metric-tooltip-item\">${escapeHtml(row.testcase)}${notes ? ' - ' + notes : ''}</div>`;
        totalTestsCopyText += `  ‚Ä¢ ${row.testcase}${copyNotes}\n`;
      });
      totalTestsCopyText += '\n';
    });
  }
  
  if (totalNotTested > 0) {
    notTestedTooltip = '<div class="metric-tooltip-header"><div class="metric-tooltip-title">Not Tested Test Cases</div><button class="metric-tooltip-copy" data-type="nottested">Copy</button></div>';
    notTestedCopyText = 'Not Tested Test Cases:\n\n';
    const notTestedByCat = {};
    data.forEach(row => {
      if (row.status === 'N' || !row.status) {
        const cat = row.category || 'Uncategorized';
        const shouldInclude = selectedCategories.size === 0 || selectedCategories.has(cat);
        if (shouldInclude) {
          if (!notTestedByCat[cat]) notTestedByCat[cat] = [];
          notTestedByCat[cat].push(row);
        }
      }
    });
    Object.keys(notTestedByCat).sort().forEach(cat => {
      const catCount = notTestedByCat[cat].length;
      notTestedTooltip += `<div class=\"metric-tooltip-category-header\">${escapeHtml(cat)} (${catCount})</div>`;
      notTestedCopyText += `${cat} (${catCount}):\n`;
      notTestedByCat[cat].forEach(row => {
        let notes = '';
        let copyNotes = '';
        if (row.notes) {
          const noteItems = row.notes.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            notes = '<span class="metric-tooltip-notes">' + noteItems.map(n => escapeHtml(n)).join('; ') + '</span>';
            copyNotes = ' (' + noteItems.join('; ') + ')';
          }
        }
        notTestedTooltip += `<div class=\"metric-tooltip-item\">${escapeHtml(row.testcase)}${notes ? ' - ' + notes : ''}</div>`;
        notTestedCopyText += `  ‚Ä¢ ${row.testcase}${copyNotes}\n`;
      });
      notTestedCopyText += '\n';
    });
  }
  
  if (totalPassed > 0) {
    passedTooltip = '<div class="metric-tooltip-header"><div class="metric-tooltip-title">Passed Test Cases</div><button class="metric-tooltip-copy" data-type="passed">Copy</button></div>';
    passedCopyText = 'Passed Test Cases:\n\n';
    const passedByCat = {};
    data.forEach(row => {
      if (row.status === 'P') {
        const cat = row.category || 'Uncategorized';
        const shouldInclude = selectedCategories.size === 0 || selectedCategories.has(cat);
        if (shouldInclude) {
          if (!passedByCat[cat]) passedByCat[cat] = [];
          passedByCat[cat].push(row);
        }
      }
    });
    Object.keys(passedByCat).sort().forEach(cat => {
      const catCount = passedByCat[cat].length;
      passedTooltip += `<div class=\"metric-tooltip-category-header\">${escapeHtml(cat)} (${catCount})</div>`;
      passedCopyText += `${cat} (${catCount}):\n`;
      passedByCat[cat].forEach(row => {
        let notes = '';
        let copyNotes = '';
        if (row.notes) {
          const noteItems = row.notes.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            notes = '<span class="metric-tooltip-notes">' + noteItems.map(n => escapeHtml(n)).join('; ') + '</span>';
            copyNotes = ' (' + noteItems.join('; ') + ')';
          }
        }
        passedTooltip += `<div class=\"metric-tooltip-item\">${escapeHtml(row.testcase)}${notes ? ' - ' + notes : ''}</div>`;
        passedCopyText += `  ‚Ä¢ ${row.testcase}${copyNotes}\n`;
      });
      passedCopyText += '\n';
    });
  }
  
  if (totalFailed > 0) {
    failedTooltip = '<div class="metric-tooltip-header"><div class="metric-tooltip-title">Failed Test Cases</div><button class="metric-tooltip-copy" data-type="failed">Copy</button></div>';
    failedCopyText = 'Failed Test Cases:\n\n';
    const failedByCat = {};
    data.forEach(row => {
      if (row.status === 'F') {
        const cat = row.category || 'Uncategorized';
        const shouldInclude = selectedCategories.size === 0 || selectedCategories.has(cat);
        if (shouldInclude) {
          if (!failedByCat[cat]) failedByCat[cat] = [];
          failedByCat[cat].push(row);
        }
      }
    });
    Object.keys(failedByCat).sort().forEach(cat => {
      const catCount = failedByCat[cat].length;
      failedTooltip += `<div class=\"metric-tooltip-category-header\">${escapeHtml(cat)} (${catCount})</div>`;
      failedCopyText += `${cat} (${catCount}):\n`;
      failedByCat[cat].forEach(row => {
        let notes = '';
        let copyNotes = '';
        if (row.notes) {
          const noteItems = row.notes.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            notes = '<span class="metric-tooltip-notes">' + noteItems.map(n => escapeHtml(n)).join('; ') + '</span>';
            copyNotes = ' (' + noteItems.join('; ') + ')';
          }
        }
        failedTooltip += `<div class=\"metric-tooltip-item\">${escapeHtml(row.testcase)}${notes ? ' - ' + notes : ''}</div>`;
        failedCopyText += `  ‚Ä¢ ${row.testcase}${copyNotes}\n`;
      });
      failedCopyText += '\n';
    });
  }
  
  if (totalBlocked > 0) {
    blockedTooltip = '<div class="metric-tooltip-header"><div class="metric-tooltip-title">Blocked Test Cases</div><button class="metric-tooltip-copy" data-type="blocked">Copy</button></div>';
    blockedCopyText = 'Blocked Test Cases:\n\n';
    const blockedByCat = {};
    data.forEach(row => {
      if (row.status === 'B') {
        const cat = row.category || 'Uncategorized';
        const shouldInclude = selectedCategories.size === 0 || selectedCategories.has(cat);
        if (shouldInclude) {
          if (!blockedByCat[cat]) blockedByCat[cat] = [];
          blockedByCat[cat].push(row);
        }
      }
    });
    Object.keys(blockedByCat).sort().forEach(cat => {
      const catCount = blockedByCat[cat].length;
      blockedTooltip += `<div class=\"metric-tooltip-category-header\">${escapeHtml(cat)} (${catCount})</div>`;
      blockedCopyText += `${cat} (${catCount}):\n`;
      blockedByCat[cat].forEach(row => {
        let notes = '';
        let copyNotes = '';
        if (row.notes) {
          const noteItems = row.notes.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            notes = '<span class="metric-tooltip-notes">' + noteItems.map(n => escapeHtml(n)).join('; ') + '</span>';
            copyNotes = ' (' + noteItems.join('; ') + ')';
          }
        }
        blockedTooltip += `<div class=\"metric-tooltip-item\">${escapeHtml(row.testcase)}${notes ? ' - ' + notes : ''}</div>`;
        blockedCopyText += `  ‚Ä¢ ${row.testcase}${copyNotes}\n`;
      });
      blockedCopyText += '\n';
    });
  }
  
  if (totalKnown > 0) {
    knownTooltip = '<div class="metric-tooltip-header"><div class="metric-tooltip-title">Known Issue Test Cases</div><button class="metric-tooltip-copy" data-type="known">Copy</button></div>';
    knownCopyText = 'Known Issue Test Cases:\n\n';
    const knownByCat = {};
    data.forEach(row => {
      if (row.status === 'K') {
        const cat = row.category || 'Uncategorized';
        const shouldInclude = selectedCategories.size === 0 || selectedCategories.has(cat);
        if (shouldInclude) {
          if (!knownByCat[cat]) knownByCat[cat] = [];
          knownByCat[cat].push(row);
        }
      }
    });
    Object.keys(knownByCat).sort().forEach(cat => {
      const catCount = knownByCat[cat].length;
      knownTooltip += `<div class=\"metric-tooltip-category-header\">${escapeHtml(cat)} (${catCount})</div>`;
      knownCopyText += `${cat} (${catCount}):\n`;
      knownByCat[cat].forEach(row => {
        let notes = '';
        let copyNotes = '';
        if (row.notes) {
          const noteItems = row.notes.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            notes = '<span class="metric-tooltip-notes">' + noteItems.map(n => escapeHtml(n)).join('; ') + '</span>';
            copyNotes = ' (' + noteItems.join('; ') + ')';
          }
        }
        knownTooltip += `<div class=\"metric-tooltip-item\">${escapeHtml(row.testcase)}${notes ? ' - ' + notes : ''}</div>`;
        knownCopyText += `  ‚Ä¢ ${row.testcase}${copyNotes}\n`;
      });
      knownCopyText += '\n';
    });
  }
  
  let skippedTooltip = '';
  let skippedCopyText = '';
  
  if (totalSkipped > 0) {
    skippedTooltip = '<div class="metric-tooltip-header"><div class="metric-tooltip-title">Skipped Test Cases</div><button class="metric-tooltip-copy" data-type="skipped">Copy</button></div>';
    skippedCopyText = 'Skipped Test Cases:\n\n';
    const skippedByCat = {};
    data.forEach(row => {
      if (row.status === 'S') {
        const cat = row.category || 'Uncategorized';
        const shouldInclude = selectedCategories.size === 0 || selectedCategories.has(cat);
        if (shouldInclude) {
          if (!skippedByCat[cat]) skippedByCat[cat] = [];
          skippedByCat[cat].push(row);
        }
      }
    });
    Object.keys(skippedByCat).sort().forEach(cat => {
      const catCount = skippedByCat[cat].length;
      skippedTooltip += `<div class=\"metric-tooltip-category-header\">${escapeHtml(cat)} (${catCount})</div>`;
      skippedCopyText += `${cat} (${catCount}):\n`;
      skippedByCat[cat].forEach(row => {
        let notes = '';
        let copyNotes = '';
        if (row.notes) {
          const noteItems = row.notes.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            notes = '<span class="metric-tooltip-notes">' + noteItems.map(n => escapeHtml(n)).join('; ') + '</span>';
            copyNotes = ' (' + noteItems.join('; ') + ')';
          }
        }
        skippedTooltip += `<div class=\"metric-tooltip-item\">${escapeHtml(row.testcase)}${notes ? ' - ' + notes : ''}</div>`;
        skippedCopyText += `  ‚Ä¢ ${row.testcase}${copyNotes}\n`;
      });
      skippedCopyText += '\n';
    });
  }

  // Build comprehensive filter summary
  let activeFilters = [];
  
  // Execution Type filter
  if (filterExecType !== 'Both') {
    const execTypeLabel = filterExecType === 'M' ? 'Manual' : 'Automated';
    activeFilters.push(`<span class="filter-tag exec-type"><strong>Type:</strong> ${execTypeLabel}</span>`);
  }
  
  // Test Scope filter
  let scopeLabel = '';
  if (filterTestScope === 'R') scopeLabel = 'Regression';
  else if (filterTestScope === 'S') scopeLabel = 'Smoke';
  else if (filterTestScope === 'Y') scopeLabel = 'Sanity';
  activeFilters.push(`<span class="filter-tag test-scope"><strong>Scope:</strong> ${scopeLabel}</span>`);

  // Age filter (only show if not Both)
  if (filterAge !== 'Both') {
    const ageLabel = filterAge === 'N' ? 'New' : 'Established';
    activeFilters.push(`<span class="filter-tag age-filter"><strong>Age:</strong> ${ageLabel}</span>`);
  }

  // Priority filter
  if (filterPriority.size > 0 && filterPriority.size < 4) {
    const priorityLabels = {
      'C': 'Critical',
      'H': 'High',
      'M': 'Medium',
      'L': 'Low'
    };
    const priorities = Array.from(filterPriority)
      .sort()
      .map(p => priorityLabels[p] || p)
      .join(', ');
    activeFilters.push(`<span class="filter-tag priority"><strong>Priority:</strong> ${priorities}</span>`);
  }
  
  // Status filter
  if (filterStatus.size > 0 && filterStatus.size < 6) {
    const statusLabels = {
      'N': 'Not Tested',
      'P': 'Passed',
      'F': 'Failed',
      'B': 'Blocked',
      'K': 'Known Issue',
      'S': 'Skipped'
    };
    const statusList = Array.from(filterStatus).map(s => statusLabels[s]).join(', ');
    activeFilters.push(`<span class="filter-tag status"><strong>Status:</strong> ${statusList}</span>`);
  } else if (filterStatus.size === 0) {
    activeFilters.push(`<span class="filter-tag status-none"><strong>Status:</strong> None Selected</span>`);
  }
  
  // Category filter
  if (selectedCategories && selectedCategories.size > 0) {
    const allCategories = getUniqueCategories();
    const selected = Array.from(selectedCategories);
    let displayNames = selected.slice(0, 2).join(', ');
    let moreCount = selected.length - 2;
    let moreText = moreCount > 0 ? ` +${moreCount} more` : '';
    let tooltip = selected.join(', ');
    if (selected.length === allCategories.length) {
      displayNames = 'All';
      moreText = '';
      tooltip = allCategories.join(', ');
    }
    activeFilters.push(`<span class="filter-tag category" title="${escapeHtml(tooltip)}"><strong>Area:</strong> ${escapeHtml(displayNames)}${moreText}</span>`);
  } else if (selectedCategories === null) {
    activeFilters.push(`<span class="filter-tag category"><strong>Area:</strong> None</span>`);
  }
  
  // Test Case keyword filter
  if (filterTestCase.trim()) {
    activeFilters.push(`<span class="filter-tag keyword"><strong>Search:</strong> "${escapeHtml(filterTestCase)}"</span>`);
  }

  // Calculate additional metrics for charts
  // Failures by priority (Critical/High failures are most important for managers)
  let criticalFailed = 0, highFailed = 0, mediumFailed = 0, lowFailed = 0;
  let criticalBlocked = 0, highBlocked = 0, mediumBlocked = 0, lowBlocked = 0;
  let criticalPassed = 0, highPassed = 0, mediumPassed = 0, lowPassed = 0;
  let criticalNotTested = 0, highNotTested = 0, mediumNotTested = 0, lowNotTested = 0;

  data.forEach(row => {
    const cat = row.category || 'Uncategorized';
    const shouldCount = selectedCategories.size === 0 || selectedCategories.has(cat);
    if (!shouldCount) return;

    const priority = row.priority;
    const status = row.status;

    if (status === 'F') {
      if (priority === 'C') criticalFailed++;
      else if (priority === 'H') highFailed++;
      else if (priority === 'M') mediumFailed++;
      else if (priority === 'L') lowFailed++;
    }
    if (status === 'B') {
      if (priority === 'C') criticalBlocked++;
      else if (priority === 'H') highBlocked++;
      else if (priority === 'M') mediumBlocked++;
      else if (priority === 'L') lowBlocked++;
    }
    if (status === 'P') {
      if (priority === 'C') criticalPassed++;
      else if (priority === 'H') highPassed++;
      else if (priority === 'M') mediumPassed++;
      else if (priority === 'L') lowPassed++;
    }
    if (status === 'N' || !status) {
      if (priority === 'C') criticalNotTested++;
      else if (priority === 'H') highNotTested++;
      else if (priority === 'M') mediumNotTested++;
      else if (priority === 'L') lowNotTested++;
    }
  });

  // Sort categories by total test count (descending) - needed for charts
  const sortedCategories = Object.entries(catMap).sort((a, b) => b[1].total - a[1].total);

  // Render Metrics Overview
  let metricsHtml = `
    <!-- Dashboard Charts Container -->
    <div class="dashboard-charts-container" id="dashboardChartsContainer">
      <div class="chart-carousel" id="chartCarousel">
          <!-- Chart 1: Test Execution Metrics (Primary Dashboard) -->
          <div class="chart-slide active" data-chart-index="0">
            <div class="chart-panel metrics-panel">
              <div class="chart-panel-header" style="flex-direction: row; justify-content: space-between; align-items: center;">
                <div style="display: flex; flex-direction: column; gap: 2px;">
                  <span class="chart-panel-title">Test Execution Summary</span>
                  <span class="chart-panel-subtitle">Status breakdown of all tests</span>
                </div>
                <span class="completion-percent-badge">${totalTests ? Math.round((totalTested/totalTests)*100) : 0}% Complete</span>
              </div>
              <div class="chart-panel-content">
                <div class="carousel-metrics-grid">
                  <div class="carousel-metric-card total">
                    <div class="carousel-metric-icon">üìä</div>
                    <div class="carousel-metric-value">${totalTests}</div>
                    <div class="carousel-metric-label">Total</div>
                    <div class="carousel-metric-subtext">${totalTested} executed</div>
                  </div>
                  <div class="carousel-metric-card not-tested">
                    <div class="carousel-metric-icon">?</div>
                    <div class="carousel-metric-value">${totalNotTested}</div>
                    <div class="carousel-metric-label">Not Tested</div>
                    <div class="carousel-metric-subtext">${totalTests ? Math.round((totalNotTested/totalTests)*100) : 0}%</div>
                  </div>
                  <div class="carousel-metric-card passed">
                    <div class="carousel-metric-icon">‚úì</div>
                    <div class="carousel-metric-value">${totalPassed}</div>
                    <div class="carousel-metric-label">Passed</div>
                    <div class="carousel-metric-subtext">${totalTests ? Math.round((totalPassed/totalTests)*100) : 0}%</div>
                  </div>
                  <div class="carousel-metric-card failed">
                    <div class="carousel-metric-icon">‚úó</div>
                    <div class="carousel-metric-value">${totalFailed}</div>
                    <div class="carousel-metric-label">Failed</div>
                    <div class="carousel-metric-subtext">${totalTests ? Math.round((totalFailed/totalTests)*100) : 0}%</div>
                  </div>
                  <div class="carousel-metric-card blocked">
                    <div class="carousel-metric-icon">‚äò</div>
                    <div class="carousel-metric-value">${totalBlocked}</div>
                    <div class="carousel-metric-label">Blocked</div>
                    <div class="carousel-metric-subtext">${totalTests ? Math.round((totalBlocked/totalTests)*100) : 0}%</div>
                  </div>
                  <div class="carousel-metric-card known">
                    <div class="carousel-metric-icon">‚ö†</div>
                    <div class="carousel-metric-value">${totalKnown}</div>
                    <div class="carousel-metric-label">Known</div>
                    <div class="carousel-metric-subtext">${totalTests ? Math.round((totalKnown/totalTests)*100) : 0}%</div>
                  </div>
                  <div class="carousel-metric-card skipped">
                    <div class="carousel-metric-icon">‚Üí</div>
                    <div class="carousel-metric-value">${totalSkipped}</div>
                    <div class="carousel-metric-label">Skipped</div>
                    <div class="carousel-metric-subtext">${totalTests ? Math.round((totalSkipped/totalTests)*100) : 0}%</div>
                  </div>
                </div>
                <div class="status-stacked-bar carousel-bar" style="margin-top: 16px;">
                  <div class="stacked-segment passed" style="width: ${totalTests ? (totalPassed/totalTests)*100 : 0}%" title="Passed: ${totalPassed}"></div>
                  <div class="stacked-segment failed" style="width: ${totalTests ? (totalFailed/totalTests)*100 : 0}%" title="Failed: ${totalFailed}"></div>
                  <div class="stacked-segment blocked" style="width: ${totalTests ? (totalBlocked/totalTests)*100 : 0}%" title="Blocked: ${totalBlocked}"></div>
                  <div class="stacked-segment known" style="width: ${totalTests ? (totalKnown/totalTests)*100 : 0}%" title="Known Issue: ${totalKnown}"></div>
                  <div class="stacked-segment skipped" style="width: ${totalTests ? (totalSkipped/totalTests)*100 : 0}%" title="Skipped: ${totalSkipped}"></div>
                  <div class="stacked-segment not-tested" style="width: ${totalTests ? (totalNotTested/totalTests)*100 : 0}%" title="Not Tested: ${totalNotTested}"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- Chart 2: Bug Severity Overview -->
          <div class="chart-slide" data-chart-index="1">
            <div class="chart-panel">
              <div class="chart-panel-header">
                <span class="chart-panel-title">Bug Severity Overview</span>
                <span class="chart-panel-subtitle">Failed & Blocked tests by priority</span>
              </div>
              <div class="chart-panel-content bug-severity-container-v2">
                <div class="bug-severity-left">
                  <div class="bug-severity-donut-large" style="background: conic-gradient(
                    ${priorityCritical + priorityHigh + priorityMedium + priorityLow > 0 ? `
                    #dc3545 0deg ${(priorityCritical / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 360}deg,
                    #fd7e14 ${(priorityCritical / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 360}deg ${((priorityCritical + priorityHigh) / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 360}deg,
                    #ffc107 ${((priorityCritical + priorityHigh) / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 360}deg ${((priorityCritical + priorityHigh + priorityMedium) / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 360}deg,
                    #28a745 ${((priorityCritical + priorityHigh + priorityMedium) / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 360}deg 360deg
                    ` : '#e9ecef 0deg 360deg'}
                  );">
                    <div class="bug-donut-hole-large">
                      <div class="bug-donut-value-large">${priorityCritical + priorityHigh + priorityMedium + priorityLow}</div>
                      <div class="bug-donut-label-large">Total Bugs</div>
                    </div>
                  </div>
                </div>
                <div class="bug-severity-right">
                  <div class="bug-bar-row-compact">
                    <span class="bug-bar-label-compact critical">Critical</span>
                    <div class="bug-bar-track-compact">
                      <div class="bug-bar-fill critical" style="width: ${(priorityCritical + priorityHigh + priorityMedium + priorityLow) > 0 ? (priorityCritical / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 100 : 0}%"></div>
                    </div>
                    <span class="bug-bar-count-compact">${priorityCritical}</span>
                  </div>
                  <div class="bug-bar-row-compact">
                    <span class="bug-bar-label-compact high">High</span>
                    <div class="bug-bar-track-compact">
                      <div class="bug-bar-fill high" style="width: ${(priorityCritical + priorityHigh + priorityMedium + priorityLow) > 0 ? (priorityHigh / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 100 : 0}%"></div>
                    </div>
                    <span class="bug-bar-count-compact">${priorityHigh}</span>
                  </div>
                  <div class="bug-bar-row-compact">
                    <span class="bug-bar-label-compact medium">Medium</span>
                    <div class="bug-bar-track-compact">
                      <div class="bug-bar-fill medium" style="width: ${(priorityCritical + priorityHigh + priorityMedium + priorityLow) > 0 ? (priorityMedium / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 100 : 0}%"></div>
                    </div>
                    <span class="bug-bar-count-compact">${priorityMedium}</span>
                  </div>
                  <div class="bug-bar-row-compact">
                    <span class="bug-bar-label-compact low">Low</span>
                    <div class="bug-bar-track-compact">
                      <div class="bug-bar-fill low" style="width: ${(priorityCritical + priorityHigh + priorityMedium + priorityLow) > 0 ? (priorityLow / (priorityCritical + priorityHigh + priorityMedium + priorityLow)) * 100 : 0}%"></div>
                    </div>
                    <span class="bug-bar-count-compact">${priorityLow}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Chart 3: Category Coverage -->
          <div class="chart-slide" data-chart-index="2">
            <div class="chart-panel">
              <div class="chart-panel-header" style="flex-direction: row; justify-content: space-between; align-items: center;">
                <div style="display: flex; flex-direction: column; gap: 2px;">
                  <span class="chart-panel-title">Category Coverage</span>
                  <span class="chart-panel-subtitle">Test completion by area</span>
                </div>
                <span class="completion-percent-badge">${totalTests ? Math.round(((totalTests - totalNotTested) / totalTests) * 100) : 0}% Complete</span>
              </div>
              <div class="chart-panel-content category-coverage-grid" id="categoryCoverageContainer">
                ${(() => {
                  const maxCatTotal = Math.max(...sortedCategories.map(([, val]) => val.total || 1));
                  const visibleCats = sortedCategories.slice(0, 12);
                  return visibleCats.map(([cat, val]) => {
                    const catTotal = val.total || 1;
                    const catTested = val.passed + val.failed + val.blocked + val.known + val.skipped;
                    const barWidth = (catTotal / maxCatTotal) * 100;
                    const testedPct = Math.round((catTested / catTotal) * 100);
                    return `
                      <div class="category-coverage-item">
                        <div class="category-coverage-info">
                          <span class="category-coverage-name" title="${cat}">${cat}</span>
                          <span class="category-coverage-stat">${testedPct}% <span class="category-coverage-count">(${catTested}/${catTotal})</span></span>
                        </div>
                        <div class="category-coverage-bar-short" style="width: ${barWidth}%;">
                          <div class="coverage-bar-tested" style="width: ${(catTested/catTotal)*100}%" title="Tested: ${catTested}/${catTotal}"></div>
                        </div>
                      </div>
                    `;
                  }).join('');
                })()}
                ${sortedCategories.length > 12 ? `
                <div class="category-coverage-expanded" id="categoryCoverageExpanded" style="display: none;">
                  ${(() => {
                    const maxCatTotal = Math.max(...sortedCategories.map(([, val]) => val.total || 1));
                    return sortedCategories.slice(12).map(([cat, val]) => {
                      const catTotal = val.total || 1;
                      const catTested = val.passed + val.failed + val.blocked + val.known + val.skipped;
                      const barWidth = (catTotal / maxCatTotal) * 100;
                      const testedPct = Math.round((catTested / catTotal) * 100);
                      return `
                        <div class="category-coverage-item">
                          <div class="category-coverage-info">
                            <span class="category-coverage-name" title="${cat}">${cat}</span>
                            <span class="category-coverage-stat">${testedPct}% <span class="category-coverage-count">(${catTested}/${catTotal})</span></span>
                          </div>
                          <div class="category-coverage-bar-short" style="width: ${barWidth}%;">
                            <div class="coverage-bar-tested" style="width: ${(catTested/catTotal)*100}%" title="Tested: ${catTested}/${catTotal}"></div>
                          </div>
                        </div>
                      `;
                    }).join('');
                  })()}
                </div>
                <div class="category-coverage-toggle" id="categoryCoverageToggle">
                  <span class="toggle-text">+${sortedCategories.length - 12} more</span>
                  <span class="toggle-icon">‚ñº</span>
                </div>
                ` : ''}
              </div>
            </div>
          </div>
        </div>
      <div class="chart-navigation">
        <button class="chart-nav-btn" id="chartPrevBtn" title="Previous Chart">‚Äπ</button>
        <div class="chart-indicators" id="chartIndicators">
          <span class="chart-indicator active" data-chart="0"></span>
          <span class="chart-indicator" data-chart="1"></span>
          <span class="chart-indicator" data-chart="2"></span>
        </div>
        <button class="chart-nav-btn" id="chartNextBtn" title="Next Chart">‚Ä∫</button>
      </div>
    </div>

    <div class="category-breakdown">
      
      <div class="category-table-wrapper" style="display:none;">
        <table class="category-table">
          <thead>
            <tr>
              <th class="cat-th-category">Category</th>
              <th class="cat-th-progress">Progress</th>
              <th class="cat-th-metric">Total</th>
              <th class="cat-th-metric">Untested</th>
              <th class="cat-th-metric">Passed</th>
              <th class="cat-th-metric">Failed</th>
              <th class="cat-th-metric">Blocked</th>
              <th class="cat-th-metric">Known</th>
              <th class="cat-th-metric">Skipped</th>
            </tr>
          </thead>
          <tbody>
  `;

  // Iterate through sorted categories (already defined above for charts)
  sortedCategories.forEach(([cat, val]) => {
    const total = val.total || 0;

    // Calculate exact percentages for progress bars
    const passedPercent = total ? (val.passed/total)*100 : 0;
    const failedBlockedPercent = total ? ((val.failed + val.blocked)/total)*100 : 0;
    const notTestedPercent = total ? (val.notTested/total)*100 : 0;
    
    // Display percentage is rounded but capped at 100%
    const testedPercent = Math.min(100, Math.round(passedPercent + failedBlockedPercent + (val.known/total)*100 + (val.skipped/total)*100));
    
    // Check if this category is selected - if selectedCategories is empty, all are considered selected
    const isSelected = selectedCategories.size === 0 || selectedCategories.has(cat);
    const selectedClass = isSelected ? ' category-selected' : '';
    
    metricsHtml += `
            <tr class="category-row${selectedClass}" data-category="${cat}">
              <td class="cat-td-category">${cat}</td>
              <td class="cat-td-progress">
                <div class="cat-progress-wrapper">
                  <div class="cat-progress-bar">
                    ${val.notTested > 0 ? `<div class="cat-progress-fill not-tested" style="width: ${notTestedPercent}%;" data-tooltip="Not Tested: ${val.notTested}"></div>` : ''}
                    ${val.passed > 0 ? `<div class="cat-progress-fill passed" style="width: ${passedPercent}%;" data-tooltip="Passed: ${val.passed}"></div>` : ''}
                    ${(val.failed + val.blocked) > 0 ? `<div class="cat-progress-fill failed" style="width: ${failedBlockedPercent}%;" data-tooltip="Failed + Blocked: ${val.failed + val.blocked}"></div>` : ''}
                  </div>
                  <span class="cat-progress-percent">${testedPercent}%</span>
                </div>
              </td>
              <td class="cat-td-metric total">${total}</td>
              <td class="cat-td-metric not-tested">${val.notTested}</td>
              <td class="cat-td-metric passed">${val.passed}</td>
              <td class="cat-td-metric failed">${val.failed}</td>
              <td class="cat-td-metric blocked">${val.blocked}</td>
              <td class="cat-td-metric known">${val.known}</td>
              <td class="cat-td-metric skipped">${val.skipped}</td>
            </tr>
    `;
  });
  
  metricsHtml += `
          </tbody>
        </table>
      </div>
    </div>
  `;
  
  metricsDiv.innerHTML = metricsHtml;

  setTimeout(() => {
    // Chart navigation functionality
    const totalCharts = 3;

    const chartIndicators = document.querySelectorAll('.chart-indicator');
    const chartPrevBtn = document.getElementById('chartPrevBtn');
    const chartNextBtn = document.getElementById('chartNextBtn');

    function updateChartView(index) {
      // Collapse category coverage if expanded when leaving that slide
      const categoryCoverageExpanded = document.getElementById('categoryCoverageExpanded');
      const categoryCoverageToggle = document.getElementById('categoryCoverageToggle');
      if (categoryCoverageExpanded && categoryCoverageToggle && categoryCoverageExpanded.style.display !== 'none') {
        categoryCoverageExpanded.style.display = 'none';
        const toggleText = categoryCoverageToggle.querySelector('.toggle-text');
        const toggleIcon = categoryCoverageToggle.querySelector('.toggle-icon');
        if (toggleText) toggleText.textContent = '+' + categoryCoverageExpanded.querySelectorAll('.category-coverage-item').length + ' more';
        if (toggleIcon) toggleIcon.textContent = '‚ñº';
        categoryCoverageToggle.classList.remove('expanded');
        // Remove expanded class from slide
        const slide = categoryCoverageToggle.closest('.chart-slide');
        if (slide) slide.classList.remove('expanded');
      }

      // Update slides
      document.querySelectorAll('.chart-slide').forEach((slide, i) => {
        slide.classList.toggle('active', i === index);
      });
      // Update indicators
      chartIndicators.forEach((indicator, i) => {
        indicator.classList.toggle('active', i === index);
      });
      currentChartIndex = index; // Update global variable
    }

    // Restore previous chart position
    updateChartView(currentChartIndex);

    if (chartPrevBtn) {
      chartPrevBtn.addEventListener('click', () => {
        const newIndex = (currentChartIndex - 1 + totalCharts) % totalCharts;
        updateChartView(newIndex);
      });
    }

    if (chartNextBtn) {
      chartNextBtn.addEventListener('click', () => {
        const newIndex = (currentChartIndex + 1) % totalCharts;
        updateChartView(newIndex);
      });
    }

    // Click on indicators
    chartIndicators.forEach((indicator, i) => {
      indicator.addEventListener('click', () => {
        updateChartView(i);
      });
    });

    // Category coverage expand/collapse toggle
    const categoryCoverageToggle = document.getElementById('categoryCoverageToggle');
    const categoryCoverageExpanded = document.getElementById('categoryCoverageExpanded');
    if (categoryCoverageToggle && categoryCoverageExpanded) {
      categoryCoverageToggle.addEventListener('click', () => {
        const isExpanded = categoryCoverageExpanded.style.display !== 'none';
        const slide = categoryCoverageToggle.closest('.chart-slide');
        if (isExpanded) {
          categoryCoverageExpanded.style.display = 'none';
          categoryCoverageToggle.querySelector('.toggle-text').textContent = '+' + categoryCoverageExpanded.querySelectorAll('.category-coverage-item').length + ' more';
          categoryCoverageToggle.querySelector('.toggle-icon').textContent = '‚ñº';
          categoryCoverageToggle.classList.remove('expanded');
          if (slide) slide.classList.remove('expanded');
        } else {
          categoryCoverageExpanded.style.display = 'grid';
          categoryCoverageToggle.querySelector('.toggle-text').textContent = 'Show less';
          categoryCoverageToggle.querySelector('.toggle-icon').textContent = '‚ñ≤';
          categoryCoverageToggle.classList.add('expanded');
          if (slide) slide.classList.add('expanded');
        }
      });
    }

    // Add event listeners for copy buttons in category detail tooltips
    document.querySelectorAll('.cat-detail-tooltip-copy').forEach(btn => {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        const tooltip = this.closest('.cat-detail-tooltip');
        const copyText = tooltip.getAttribute('data-copy-text');
        
        navigator.clipboard.writeText(copyText).then(() => {
          this.textContent = 'Copied!';
          this.style.background = '#28a745';
          this.style.borderColor = '#28a745';
          
          const catDetail = tooltip.closest('.cat-detail');
          const resetButton = () => {
            this.textContent = 'Copy';
            this.style.background = '';
            this.style.borderColor = '';
            catDetail.removeEventListener('mouseleave', resetButton);
          };
          catDetail.addEventListener('mouseleave', resetButton);
        }).catch(err => {
          console.error('Failed to copy:', err);
          this.textContent = 'Error';
          this.style.background = '#dc3545';
        });
      });
    });
    // Add event listeners for category row selection
    document.querySelectorAll('.category-row').forEach(row => {
      row.addEventListener('click', function(e) {
        const category = this.getAttribute('data-category');
        
        // Get all categories from the current filtered data
        const allCategories = new Set();
        data.forEach(r => {
          if (r.category) allCategories.add(r.category);
        });
        
        // If all categories are currently selected (empty set)
        if (selectedCategories.size === 0) {
          // Select only this category
          selectedCategories = new Set([category]);
        } else if (selectedCategories.has(category)) {
          // Remove this category from selection
          selectedCategories.delete(category);
          // If no categories left, that means "select all" (empty set)
          if (selectedCategories.size === 0) {
            selectedCategories = new Set();
          }
        } else {
          // Add this category to selection
          selectedCategories.add(category);
          // Check if we now have all categories selected
          if (selectedCategories.size === allCategories.size) {
            // Reset to "all selected" state (empty set)
            selectedCategories = new Set();
          }
        }
        
        // Re-render table which will update metrics
        renderTable(csvData);
      });
      
      // Add visual feedback on hover
      row.style.cursor = 'pointer';
    });
    
    // Add event listener for clear active filters button
    const clearActiveFiltersBtn = document.getElementById('clearActiveFilters');
    if (clearActiveFiltersBtn) {
      clearActiveFiltersBtn.addEventListener('click', function() {
        // Reset execution type to Both
        filterExecType = 'Both';
        document.querySelector('input[name="execType"][value="Both"]').checked = true;
        
        // Reset test scope to Regression
        filterTestScope = 'R';
        document.querySelector('input[name="testScope"][value="R"]').checked = true;

        // Reset age filter to Both
        filterAge = 'Both';
        document.querySelector('input[name="ageFilter"][value="Both"]').checked = true;

        // Reset priority to all selected
        filterPriority = new Set(['C', 'H', 'M', 'L']);
        document.querySelectorAll('.priority-filter-btn').forEach(btn => {
          btn.classList.add('active');
        });

        // Reset status filters to all selected
        filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);
        document.querySelectorAll('.status-filter-btn').forEach(btn => {
          btn.classList.add('active');
        });
        
        // Clear test case search
        filterTestCase = '';
        const testCaseInput = document.getElementById('testCaseFilter');
        if (testCaseInput) {
          testCaseInput.value = '';
        }
        
        // Clear category selection
        selectedCategories.clear();
        
        // Save and re-render
        saveToCache();
        renderTable(csvData);
      });
    }
  }, 0);
  
  data.forEach(row => {
    const cat = row.category || 'Uncategorized';
    if (!catMap[cat]) catMap[cat] = { total: 0, passed: 0, failed: 0, blocked: 0, known: 0, skipped: 0, notTested: 0 };
    catMap[cat].total++;
    totalTests++;
    
    if (row.status === 'N' || !row.status) {
      catMap[cat].notTested++;
      totalNotTested++;
    }
    if (row.status === 'P') {
      catMap[cat].passed++;
      totalPassed++;
    }
    if (row.status === 'F') {
      catMap[cat].failed++;
      totalFailed++;
      if (!failedMap[cat]) failedMap[cat] = [];
      failedMap[cat].push(row.testcase);
    }
    if (row.status === 'B') {
      catMap[cat].blocked++;
      totalBlocked++;
      if (!blockedMap[cat]) blockedMap[cat] = [];
      blockedMap[cat].push(row.testcase);
    }
    if (row.status === 'K') {
      catMap[cat].known++;
      totalKnown++;
      if (!knownMap[cat]) knownMap[cat] = [];
      knownMap[cat].push(row.testcase);
    }
    if (row.status === 'S') {
      catMap[cat].skipped++;
      totalSkipped++;
    }
  });
  
  // Category summary is now in metrics, so clear this section
  summaryDiv.innerHTML = '';
}

/* ==========================================
   INLINE ROW EDITOR
   ========================================== */

let currentlyEditingRow = null; // Track which row is being edited

function createRowEditor(rowData, rowIdx, targetRow) {
  // Close any existing editor
  if (currentlyEditingRow !== null) {
    closeRowEditor();
  }

  // Get all unique categories for dropdown
  const categories = getUniqueCategories();
  
  // Store original data for cancel
  const originalData = {...rowData};
  
  // Create editor container
  const editorRow = document.createElement('tr');
  editorRow.classList.add('row-edit-row');
  
  const editorCell = document.createElement('td');
  editorCell.setAttribute('colspan', '4');
  
  const editorContainer = document.createElement('div');
  editorContainer.classList.add('row-edit-container');
  
  // Determine if this is an add (new) or edit
  const isAddMode = !rowData.id && rowData.testcase === '';
  // Build the form HTML with defaults for add mode
  const defaultType = rowData.type || 'M';
  const defaultScope = rowData.scope || 'R';
  const defaultStatus = rowData.status || 'N';
  // Priority: use '-' for non-bug statuses (not F or B)
  const isBugStatus = defaultStatus === 'F' || defaultStatus === 'B';
  const defaultPriority = isBugStatus ? (rowData.priority || 'M') : '-';
  const defaultCategory = rowData.category || '';
  const defaultAge = rowData.age || '';
  
  editorContainer.innerHTML = `
    <div class="row-edit-title">${isAddMode ? '‚ûï Add Test Case' : `‚úèÔ∏è Edit Test Case #${rowIdx + 1}`}</div>
    <div class="row-edit-form">
      <div class="row-edit-field">
        <label class="row-edit-label">Category / Area</label>
        <select class="row-edit-select" id="edit-category-${rowIdx}">
          <option value="" ${defaultCategory === '' ? 'selected' : ''}>-- Select Category --</option>
          ${categories.map(cat => `<option value="${cat}" ${defaultCategory === cat ? 'selected' : ''}>${cat}</option>`).join('')}
        </select>
      </div>
      
      <div class="row-edit-field">
        <label class="row-edit-label">Type</label>
        <select class="row-edit-select" id="edit-type-${rowIdx}">
          <option value="M" ${defaultType === 'M' ? 'selected' : ''}>Manual</option>
          <option value="A" ${defaultType === 'A' ? 'selected' : ''}>Automated</option>
        </select>
      </div>
      
      <div class="row-edit-field">
        <label class="row-edit-label">Scope</label>
        <select class="row-edit-select" id="edit-scope-${rowIdx}">
          <option value="R" ${defaultScope === 'R' ? 'selected' : ''}>Regression</option>
          <option value="S" ${defaultScope === 'S' ? 'selected' : ''}>Smoke</option>
          <option value="Y" ${defaultScope === 'Y' ? 'selected' : ''}>Sanity</option>
        </select>
      </div>
      
      <div class="row-edit-field">
        <label class="row-edit-label">Status</label>
        <select class="row-edit-select" id="edit-status-${rowIdx}">
          <option value="N" ${defaultStatus === 'N' ? 'selected' : ''}>Not Tested</option>
          <option value="P" ${defaultStatus === 'P' ? 'selected' : ''}>Passed</option>
          <option value="F" ${defaultStatus === 'F' ? 'selected' : ''}>Failed</option>
          <option value="B" ${defaultStatus === 'B' ? 'selected' : ''}>Blocked</option>
          <option value="K" ${defaultStatus === 'K' ? 'selected' : ''}>Known Issue</option>
          <option value="S" ${defaultStatus === 'S' ? 'selected' : ''}>Skipped</option>
        </select>
      </div>

      <div class="row-edit-field" id="edit-priority-field-${rowIdx}" style="${isBugStatus ? '' : 'opacity: 0.5;'}">
        <label class="row-edit-label">Priority ${isBugStatus ? '' : '(N/A)'}</label>
        <select class="row-edit-select" id="edit-priority-${rowIdx}" ${isBugStatus ? '' : 'disabled'}>
          <option value="-" ${defaultPriority === '-' ? 'selected' : ''}>- (N/A)</option>
          <option value="C" ${defaultPriority === 'C' ? 'selected' : ''}>Critical</option>
          <option value="H" ${defaultPriority === 'H' ? 'selected' : ''}>High</option>
          <option value="M" ${defaultPriority === 'M' ? 'selected' : ''}>Medium</option>
          <option value="L" ${defaultPriority === 'L' ? 'selected' : ''}>Low</option>
        </select>
      </div>

      <div class="row-edit-field">
        <label class="row-edit-label">Age</label>
        <select class="row-edit-select" id="edit-age-${rowIdx}">
          <option value="" ${defaultAge === '' ? 'selected' : ''}>-- Select --</option>
          <option value="N" ${defaultAge === 'N' ? 'selected' : ''}>New</option>
          <option value="O" ${defaultAge === 'O' ? 'selected' : ''}>Established</option>
        </select>
      </div>

      <div class="row-edit-field" style="grid-column: 1 / -1; flex-direction: column;">
        <label class="row-edit-label">Test Case Description</label>
        <input type="text" class="row-edit-input" id="edit-testcase-${rowIdx}" value="${(rowData.testcase || '').replace(/"/g, '&quot;')}">
        <div class="row-edit-error-msg" id="edit-testcase-error-${rowIdx}">‚ö†Ô∏è Commas are not allowed (CSV format)</div>
      </div>
      
      <div style="grid-column: 1 / -1; display: flex; gap: 12px;">
        <div style="flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 4px;">
          <label class="row-edit-label">Notes (use | to separate multiple notes)</label>
          <input type="text" class="row-edit-input" id="edit-notes-${rowIdx}" value="${(rowData.notes || '').replace(/"/g, '&quot;')}">
          <div class="row-edit-error-msg" id="edit-notes-error-${rowIdx}">‚ö†Ô∏è Commas are not allowed (CSV format)</div>
        </div>
        
        <div style="flex: 0 0 140px; min-width: 140px; display: flex; flex-direction: column; gap: 4px;">
          <label class="row-edit-label">Jira Ticket</label>
          <input type="text" class="row-edit-input jira-input" id="edit-jira-${rowIdx}" value="${(rowData.jira || '').replace(/"/g, '&quot;')}" placeholder="e.g., LP-3432">
          <div class="row-edit-error-msg" id="edit-jira-error-${rowIdx}">‚ö†Ô∏è Commas are not allowed (CSV format)</div>
        </div>
      </div>
    </div>
    
    <div class="row-edit-actions">
      ${isAddMode ? '' : `<button class="row-edit-btn row-edit-btn-delete" id="edit-delete-${rowIdx}">Delete</button>`}
      <button class="row-edit-btn row-edit-btn-cancel" id="edit-cancel-${rowIdx}">Cancel</button>
      <button class="row-edit-btn row-edit-btn-save hidden" id="edit-save-${rowIdx}">${isAddMode ? 'Add Test Case' : 'Save Changes'}</button>
    </div>
  `;
  
  editorCell.appendChild(editorContainer);
  editorRow.appendChild(editorCell);
  
  // Insert editor row
  if (isAddMode) {
    // For add mode, insert at the top of the table body
    const tbody = document.querySelector('#testTable tbody');
    if (tbody && tbody.firstChild) {
      tbody.insertBefore(editorRow, tbody.firstChild);
    } else if (tbody) {
      tbody.appendChild(editorRow);
    }
  } else {
    // For edit mode, insert after the target row
    targetRow.parentNode.insertBefore(editorRow, targetRow.nextSibling);
    // Mark the target row as being edited
    targetRow.classList.add('row-editing');
  }
  
  currentlyEditingRow = {rowIdx, targetRow, editorRow, originalData, hasChanges: false, isAddMode};
  
  // Get save button reference
  const saveBtn = document.getElementById(`edit-save-${rowIdx}`);
  saveBtn.classList.add('hidden'); // Initially hidden
  
  // Track changes in all form fields
  const formFields = [
    document.getElementById(`edit-category-${rowIdx}`),
    document.getElementById(`edit-type-${rowIdx}`),
    document.getElementById(`edit-scope-${rowIdx}`),
    document.getElementById(`edit-priority-${rowIdx}`),
    document.getElementById(`edit-status-${rowIdx}`),
    document.getElementById(`edit-age-${rowIdx}`),
    document.getElementById(`edit-testcase-${rowIdx}`),
    document.getElementById(`edit-notes-${rowIdx}`),
    document.getElementById(`edit-jira-${rowIdx}`)
  ];
  
  function validateFields() {
    const testcaseField = document.getElementById(`edit-testcase-${rowIdx}`);
    const notesField = document.getElementById(`edit-notes-${rowIdx}`);
    const jiraField = document.getElementById(`edit-jira-${rowIdx}`);
    const testcaseError = document.getElementById(`edit-testcase-error-${rowIdx}`);
    const notesError = document.getElementById(`edit-notes-error-${rowIdx}`);
    const jiraError = document.getElementById(`edit-jira-error-${rowIdx}`);
    
    let isValid = true;
    
    // Check for commas in test case
    if (testcaseField.value.includes(',')) {
      testcaseField.classList.add('error');
      testcaseError.classList.add('show');
      isValid = false;
    } else {
      testcaseField.classList.remove('error');
      testcaseError.classList.remove('show');
    }
    
    // Check for commas in notes
    if (notesField.value.includes(',')) {
      notesField.classList.add('error');
      notesError.classList.add('show');
      isValid = false;
    } else {
      notesField.classList.remove('error');
      notesError.classList.remove('show');
    }
    
    // Check for commas in jira
    if (jiraField.value.includes(',')) {
      jiraField.classList.add('error');
      jiraError.classList.add('show');
      isValid = false;
    } else {
      jiraField.classList.remove('error');
      jiraError.classList.remove('show');
    }
    
    return isValid;
  }
  
  function checkForChanges() {
    // For add mode, show Save button if testcase is not empty
    if (isAddMode) {
      const testcaseValue = document.getElementById(`edit-testcase-${rowIdx}`).value.trim();
      const isValid = validateFields();
      if (testcaseValue && isValid) {
        saveBtn.classList.remove('hidden');
      } else {
        saveBtn.classList.add('hidden');
      }
      currentlyEditingRow.hasChanges = !!testcaseValue;
      return;
    }
    
    // For edit mode, check for actual changes
    const hasChanges =
      document.getElementById(`edit-category-${rowIdx}`).value !== originalData.category ||
      document.getElementById(`edit-type-${rowIdx}`).value !== originalData.type ||
      document.getElementById(`edit-scope-${rowIdx}`).value !== originalData.scope ||
      document.getElementById(`edit-priority-${rowIdx}`).value !== originalData.priority ||
      document.getElementById(`edit-status-${rowIdx}`).value !== originalData.status ||
      document.getElementById(`edit-age-${rowIdx}`).value !== (originalData.age || '') ||
      document.getElementById(`edit-testcase-${rowIdx}`).value !== (originalData.testcase || '') ||
      document.getElementById(`edit-notes-${rowIdx}`).value !== (originalData.notes || '') ||
      document.getElementById(`edit-jira-${rowIdx}`).value !== (originalData.jira || '');
    
    const isValid = validateFields();
    
    // Show button only if there are changes AND no errors
    if (hasChanges && isValid) {
      saveBtn.classList.remove('hidden');
    } else {
      saveBtn.classList.add('hidden');
    }
    
    currentlyEditingRow.hasChanges = hasChanges;
  }
  
  // Add change listeners to all fields
  formFields.forEach(field => {
    field.addEventListener('input', checkForChanges);
    field.addEventListener('change', checkForChanges);
  });

  // Add status change listener to toggle priority field
  const statusField = document.getElementById(`edit-status-${rowIdx}`);
  const priorityField = document.getElementById(`edit-priority-${rowIdx}`);
  const priorityFieldContainer = document.getElementById(`edit-priority-field-${rowIdx}`);
  const priorityLabel = priorityFieldContainer.querySelector('.row-edit-label');

  statusField.addEventListener('change', function() {
    const isBug = this.value === 'F' || this.value === 'B';
    if (isBug) {
      priorityField.disabled = false;
      priorityFieldContainer.style.opacity = '1';
      priorityLabel.textContent = 'Priority';
      // If currently set to '-', default to Medium
      if (priorityField.value === '-') {
        priorityField.value = 'M';
      }
    } else {
      priorityField.disabled = true;
      priorityFieldContainer.style.opacity = '0.5';
      priorityLabel.textContent = 'Priority (N/A)';
      priorityField.value = '-';
    }
    checkForChanges();
  });
  
  // Add keyboard shortcuts
  function handleKeyDown(e) {
    if (e.key === 'Escape') {
      e.preventDefault();
      closeRowEditor();
    } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      if (!saveBtn.classList.contains('hidden')) {
        saveRowEdit(rowIdx);
      }
    }
  }
  
  formFields.forEach(field => {
    field.addEventListener('keydown', handleKeyDown);
  });
  
  // Add event listeners for save and cancel
  saveBtn.addEventListener('click', function() {
    saveRowEdit(rowIdx);
  });
  
  document.getElementById(`edit-cancel-${rowIdx}`).addEventListener('click', function() {
    closeRowEditor();
  });
  
  const deleteBtn = document.getElementById(`edit-delete-${rowIdx}`);
  if (deleteBtn) {
    deleteBtn.addEventListener('click', function() {
      deleteRow(rowIdx);
    });
  }
  
  // Focus on test case field
  document.getElementById(`edit-testcase-${rowIdx}`).focus();
  
  // Scroll the editor into view
  setTimeout(() => {
    editorRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }, 100);
}

function saveRowEdit(rowIdx) {
  if (currentlyEditingRow === null || currentlyEditingRow.rowIdx !== rowIdx) return;
  
  // Validate fields before saving
  const testcaseValue = document.getElementById(`edit-testcase-${rowIdx}`).value;
  const notesValue = document.getElementById(`edit-notes-${rowIdx}`).value;
  const jiraValue = document.getElementById(`edit-jira-${rowIdx}`).value;
  
  if (testcaseValue.includes(',') || notesValue.includes(',') || jiraValue.includes(',')) {
    alert('Cannot save: Commas are not allowed in Test Case, Notes, or Jira fields (CSV format restriction).');
    return;
  }
  
  // Get updated values from form
  const updatedData = {
    type: document.getElementById(`edit-type-${rowIdx}`).value,
    scope: document.getElementById(`edit-scope-${rowIdx}`).value,
    priority: document.getElementById(`edit-priority-${rowIdx}`).value,
    status: document.getElementById(`edit-status-${rowIdx}`).value,
    category: document.getElementById(`edit-category-${rowIdx}`).value,
    testcase: document.getElementById(`edit-testcase-${rowIdx}`).value,
    notes: document.getElementById(`edit-notes-${rowIdx}`).value,
    jira: document.getElementById(`edit-jira-${rowIdx}`).value,
    age: document.getElementById(`edit-age-${rowIdx}`).value
  };
  
  // Check if this is add mode (new test case)
  const isAddMode = currentlyEditingRow.isAddMode;
  
  if (isAddMode) {
    // Add new test case to csvData
    csvData.push(updatedData);
  } else {
    // Update existing test case
    csvData[rowIdx] = {...csvData[rowIdx], ...updatedData};
  }
  
  // Save to cache and re-render
  saveToCache();
  closeRowEditor();
  renderTable(csvData);
}

function deleteRow(rowIdx) {
  if (currentlyEditingRow === null || currentlyEditingRow.rowIdx !== rowIdx) return;
  
  const testCaseDesc = csvData[rowIdx].testcase || 'this test case';
  const confirmMsg = `Are you sure you want to delete test case #${rowIdx + 1}?\n\n"${testCaseDesc}"\n\nThis action cannot be undone.`;
  
  if (confirm(confirmMsg)) {
    // Remove the row from csvData
    csvData.splice(rowIdx, 1);
    
    // Re-assign IDs to maintain sequential order
    csvData.forEach((row, index) => {
      row.id = index + 1;
    });
    
    // Save to cache and re-render
    saveToCache();
    closeRowEditor();
    renderTable(csvData);
  }
}

function closeRowEditor() {
  if (currentlyEditingRow === null) return;
  
  // Remove editing class from target row
  if (currentlyEditingRow.targetRow) {
    currentlyEditingRow.targetRow.classList.remove('row-editing');
  }
  
  // Remove editor row
  if (currentlyEditingRow.editorRow && currentlyEditingRow.editorRow.parentNode) {
    currentlyEditingRow.editorRow.parentNode.removeChild(currentlyEditingRow.editorRow);
  }
  
  currentlyEditingRow = null;
}

/* ==========================================
   TABLE RENDERING - Main Test Case Table
   ========================================== */

function renderTable(data) {
  const tbody = document.querySelector('#testTable tbody');
  tbody.innerHTML = '';
  if (!data.length) { renderCategorySummary([]); return; }
  // Filter data by Execution Type, Test Scope, Priority, Status, and Test Case keyword
  let filtered = data.filter(row => {
    let execMatch = (filterExecType === 'Both') || (row.type === filterExecType);
    let scopeMatch = false;
    if (filterTestScope === 'Y') {
      // Sanity: smallest subset (prod testing)
      scopeMatch = (row.scope === 'Y');
    } else if (filterTestScope === 'S') {
      // Smoke: includes Smoke + Sanity
      scopeMatch = (row.scope === 'S' || row.scope === 'Y');
    } else if (filterTestScope === 'R') {
      // Regression: includes all (R + S + Y)
      scopeMatch = (row.scope === 'R' || row.scope === 'S' || row.scope === 'Y');
    }
    // Age filter
    let ageMatch = true;
    if (filterAge === 'N') {
      ageMatch = (row.age === 'N');
    } else if (filterAge === 'O') {
      ageMatch = (row.age === 'O' || !row.age);
    }
    // Both = show all
    // Priority filter only applies to bugs (Failed/Blocked) - other statuses ignore priority
    const isBugStatus = (row.status === 'F' || row.status === 'B');
    let priorityMatch = filterPriority.size === 4 || !isBugStatus || filterPriority.has(row.priority);
    let statusMatch = filterStatus.has(row.status || 'N');
    let testCaseMatch = true;
    if (filterTestCase.trim()) {
      const keyword = filterTestCase.toLowerCase();
      const testcase = (row.testcase || '').toLowerCase();
      const notes = (row.notes || '').toLowerCase();
      testCaseMatch = testcase.includes(keyword) || notes.includes(keyword);
    }
    // Jira filter
    let jiraMatch = true;
    if (jiraFilter === 'with-jira') {
      jiraMatch = !!(row.jira && row.jira.trim());
    } else if (jiraFilter === 'without-jira') {
      jiraMatch = !(row.jira && row.jira.trim());
    }
    // Pin filter - check if testcase starts with *
    let pinMatch = true;
    if (filterPinned) {
      const testcase = row.testcase || '';
      pinMatch = testcase.startsWith('*');
    }
    // Question filter - check if testcase starts with ?
    let questionMatch = true;
    if (filterQuestions) {
      const testcase = row.testcase || '';
      questionMatch = testcase.startsWith('?');
    }
    // Retest filter - check if testcase starts with @
    let retestMatch = true;
    if (filterRetest) {
      const testcase = row.testcase || '';
      retestMatch = testcase.startsWith('@');
    }
    // Pending Jira filter - check if testcase starts with !
    let pendingJiraMatch = true;
    if (filterPendingJira) {
      const testcase = row.testcase || '';
      pendingJiraMatch = testcase.startsWith('!');
    }
    // Cleanup filter - check if testcase starts with ~
    let cleanupMatch = true;
    if (filterCleanup) {
      const testcase = row.testcase || '';
      cleanupMatch = testcase.startsWith('~');
    }
    return execMatch && scopeMatch && ageMatch && priorityMatch && statusMatch && testCaseMatch && jiraMatch && pinMatch && questionMatch && retestMatch && pendingJiraMatch && cleanupMatch;
  });
  
  // Check if filtered is empty and show appropriate message
  if (filtered.length === 0) {
    renderCategorySummary([]);
    return;
  }
  
  // Group data by category
  const grouped = {};
  filtered.forEach(row => {
    const cat = row.category || 'Uncategorized';
    if (!grouped[cat]) grouped[cat] = [];
    // Find the original index in csvData
    const originalIdx = data.indexOf(row);
    grouped[cat].push({ ...row, _idx: originalIdx });
  });
  
  // Further filter grouped categories based on selectedCategories
  let categoriesToShow = [];
  if (selectedCategories === null) {
    categoriesToShow = [];
  } else {
    categoriesToShow = Object.entries(grouped).filter(([cat, rows]) => {
      return selectedCategories.size === 0 || selectedCategories.has(cat);
    });
  }

  categoriesToShow.forEach(([cat, rows]) => {
    const isCollapsed = collapsedCategories.has(cat);
    
    // Sort rows by Jira if enabled
    if (jiraSortOrder !== 'default') {
      rows.sort((a, b) => {
        const aHasJira = !!(a.jira && a.jira.trim());
        const bHasJira = !!(b.jira && b.jira.trim());
        
        if (jiraSortOrder === 'with-first') {
          // With Jira first
          if (aHasJira && !bHasJira) return -1;
          if (!aHasJira && bHasJira) return 1;
        } else if (jiraSortOrder === 'without-first') {
          // Without Jira first
          if (!aHasJira && bHasJira) return -1;
          if (aHasJira && !bHasJira) return 1;
        }
        
        // If both have or both don't have Jira, maintain order by ID
        return (a.id || 0) - (b.id || 0);
      });
    }
    // Sort rows by criticality if enabled
    else if (sortByCriticality) {
      const statusPriority = { 'F': 4, 'B': 3, 'P': 2, 'K': 1, 'S': 0, 'N': 0 };
      const priorityValue = { 'C': 4, 'H': 3, 'M': 2, 'L': 1 };
      
      rows.sort((a, b) => {
        // First sort by status (Failed > Blocked > Passed > Known Issue > Skipped/Not Tested)
        const statusDiff = (statusPriority[b.status] || 0) - (statusPriority[a.status] || 0);
        if (statusDiff !== 0) return statusDiff;
        
        // Then by priority (Critical > High > Medium > Low)
        const priorityDiff = (priorityValue[b.priority] || 0) - (priorityValue[a.priority] || 0);
        if (priorityDiff !== 0) return priorityDiff;
        
        // Finally by ID to maintain some consistency
        return (a.id || 0) - (b.id || 0);
      });
    }
    
    const rowCount = rows.length;
    
    // Calculate % complete for this category (same logic as Progress by Category)
    const catCounts = {
      passed: rows.filter(r => r.status === 'P').length,
      failed: rows.filter(r => r.status === 'F').length,
      blocked: rows.filter(r => r.status === 'B').length,
      known: rows.filter(r => r.status === 'K').length,
      skipped: rows.filter(r => r.status === 'S').length
    };
    const catTotal = rows.length;
    const catTestedCount = catCounts.passed + catCounts.failed + catCounts.blocked + catCounts.known + catCounts.skipped;
    const catTestedPercent = catTotal ? Math.min(100, Math.round((catTestedCount / catTotal) * 100)) : 0;
    
    // Create progress bar HTML
    const progressBarHtml = `
      <div style="display: inline-block; width: 80px; height: 8px; background: #e8ecf1; border-radius: 4px; margin-left: 12px; vertical-align: middle; overflow: hidden;">
        <div style="width: ${catTestedPercent}%; height: 100%; background: linear-gradient(90deg, #4caf50 0%, #66bb6a ${catTestedPercent}%); border-radius: 4px; transition: width 0.3s ease;"></div>
      </div>
      <span style="font-size: 12px; color: #6c7a8a; margin-left: 6px; font-weight: 500;">${catTestedPercent}%</span>
    `;
    
    // Insert sub-header row for category
    const subTr = document.createElement('tr');
    subTr.style.background = '#eaf1fb';
    subTr.style.fontWeight = 'bold';
    subTr.style.cursor = 'pointer';
    subTr.setAttribute('data-category', cat);
    subTr.classList.add('category-header');
    // Only show action buttons when category is expanded
    let actionButtons = '';
    if (!isCollapsed) {
      actionButtons = `
        <button class="cat-action-btn" data-cat="${cat}" data-action="passed" style="margin-left:24px; font-size:12px; padding:3px 10px; border-radius:4px; border:1px solid #bfc7d1; background:#e0f7e9; color:#217a3a; cursor:pointer;">Set All Passed</button>
        <button class="cat-action-btn" data-cat="${cat}" data-action="reset" style="margin-left:8px; font-size:12px; padding:3px 10px; border-radius:4px; border:1px solid #bfc7d1; background:#f7e0e0; color:#a12a2a; cursor:pointer;">Reset All</button>
      `;
    }
    
    subTr.innerHTML = `
      <td colspan="5" style="padding: 8px 6px 8px 18px; font-size: 14px; color: #205080;">
        ${cat} <span style="font-size: 13px; color: #6c7a8a; font-weight: 500; margin-left: 6px;">(${rowCount})</span>
        ${progressBarHtml}
        ${actionButtons}
      </td>
    `;
    tbody.appendChild(subTr);
    
    // Add click handler for collapse/expand
    subTr.addEventListener('click', function(e) {
      // Don't toggle if clicking on buttons
      if (e.target.tagName === 'BUTTON') return;
      
      if (collapsedCategories.has(cat)) {
        collapsedCategories.delete(cat);
      } else {
        collapsedCategories.add(cat);
      }
      renderTable(csvData);
    });
    
    // Insert test case rows for this category (only if not collapsed)
    if (!isCollapsed) {
      rows.forEach(rowObj => {
      const idx = rowObj._idx;
      const tr = document.createElement('tr');

      const status = rowObj.status || 'N';
      // Style for failed test case
      const tcClass = status === 'F' ? 'tc-failed' : '';
      
      // Add subtle background tint based on status
      let rowBackgroundColor = '';
      if (status === 'P') {
        rowBackgroundColor = 'background: linear-gradient(90deg, rgba(76, 175, 80, 0.04) 0%, rgba(255, 255, 255, 0) 100%);';
      } else if (status === 'F') {
        rowBackgroundColor = 'background: linear-gradient(90deg, rgba(244, 67, 54, 0.04) 0%, rgba(255, 255, 255, 0) 100%);';
      } else if (status === 'B') {
        rowBackgroundColor = 'background: linear-gradient(90deg, rgba(255, 152, 0, 0.04) 0%, rgba(255, 255, 255, 0) 100%);';
      } else if (status === 'K') {
        rowBackgroundColor = 'background: linear-gradient(90deg, rgba(255, 193, 7, 0.04) 0%, rgba(255, 255, 255, 0) 100%);';
      }
      tr.style.cssText = rowBackgroundColor;
      
      // Notes value
      const notesVal = typeof rowObj.notes === 'undefined' ? '' : rowObj.notes;

      // Status button colors and symbols
      let statusColor = '#e8ecef'; // gray for Not Tested (matches filter)
      let statusSymbol = '?';
      let statusText = 'Not Tested';
      if (status === 'P') {
        statusColor = '#c3e6cb';
        statusSymbol = '‚úì';
        statusText = 'Passed';
      } else if (status === 'F') {
        statusColor = '#f5c6cb';
        statusSymbol = '‚úó';
        statusText = 'Failed';
      } else if (status === 'B') {
        statusColor = '#ffe0b2';
        statusSymbol = '‚äò';
        statusText = 'Blocked';
      } else if (status === 'K') {
        statusColor = '#fff3cd';
        statusSymbol = '‚ö†';
        statusText = 'Known Issue';
      } else if (status === 'S') {
        statusColor = '#e8eaf6';
        statusSymbol = '‚Üí';
        statusText = 'Skipped';
      }

      // Visual styling for Test Case based on type and scope
      let tcStyle = '';
      let tcExtraClass = '';
      const isAutomated = rowObj.type === 'A';
      const isSmoke = rowObj.scope === 'S';

      // Priority-based styling
      // Remove vertical color bar for all priorities
      tcStyle = '';

      // Build testcase cell content
      let tcContent;
      // Show the test case and note below it
        let shouldBold = (rowObj.status === 'F' || rowObj.status === 'B' || rowObj.status === 'K');
        let isSkipped = rowObj.status === 'S';
        let isPassed = rowObj.status === 'P';
        let isKnown = rowObj.status === 'K';
        let style = '';
        if (isSkipped) style += 'color:#888c94;';
        if (isPassed) style += 'text-decoration: line-through; text-decoration-color: #8fa3b7;';
        if (isKnown) style += 'color:#d9534f;'; // slightly darker light red for known issue
        
        // Check if testcase has special markers (*, ?, @, !, ~)
        let testcaseText = rowObj.testcase || '';
        let isPinned = testcaseText.startsWith('*');
        let hasQuestion = testcaseText.startsWith('?');
        let needsRetest = testcaseText.startsWith('@');
        let hasPendingJira = testcaseText.startsWith('!');
        let needsCleanup = testcaseText.startsWith('~');
        
        if (isPinned) {
          testcaseText = testcaseText.substring(1).trim(); // Remove the * prefix
        } else if (hasQuestion) {
          testcaseText = testcaseText.substring(1).trim(); // Remove the ? prefix
        } else if (needsRetest) {
          testcaseText = testcaseText.substring(1).trim(); // Remove the @ prefix
        } else if (hasPendingJira) {
          testcaseText = testcaseText.substring(1).trim(); // Remove the ! prefix
        } else if (needsCleanup) {
          testcaseText = testcaseText.substring(1).trim(); // Remove the ~ prefix
        }
        
        let mainLine = shouldBold
          ? `<b style=\"${style}\">${testcaseText}</b>`
          : `<span style=\"${style}\">${testcaseText}</span>`;
        
        // Add pin icon if pinned
        if (isPinned) {
          mainLine = `<span class="pin-icon" style="color: #f39c12; margin-right: 4px;">üìå</span>` + mainLine;
        }
        // Add question icon if has question
        if (hasQuestion) {
          mainLine = `<span class="question-icon" style="color: #e74c3c; margin-right: 4px;">‚ùì</span>` + mainLine;
        }
        // Add retest icon if needs retest
        if (needsRetest) {
          mainLine = `<span class="retest-icon" style="color: #ff6b35; margin-right: 4px;">üîÑ</span>` + mainLine;
        }
        // Add pending Jira icon if pending Jira ticket
        if (hasPendingJira) {
          mainLine = `<span class="pending-jira-icon" style="color: #ff6b6b; margin-right: 4px;">üêû</span>` + mainLine;
        }
        // Add cleanup icon if needs cleanup
        if (needsCleanup) {
          mainLine = `<span class="cleanup-icon" style="color: #9b59b6; margin-right: 4px;">üßΩ</span>` + mainLine;
        }
        
        // Add New! tag if age is N (new feature)
        if (rowObj.age === 'N') {
          mainLine += '<span class="new-scope-tag">New!</span>';
        }
        let noteLine = '';
        if (notesVal && notesVal.trim() !== '') {
          const noteItems = notesVal.split('|').map(n => n.trim()).filter(n => n);
          if (noteItems.length > 0) {
            noteLine = `<div style=\"font-style:italic; color:#888c94; font-size:12px; margin-top:2px; margin-bottom:0; padding-left:8px;\">` +
              noteItems.map(n => `- ${escapeHtml(n)}`).join('<br>') +
              `</div>`;
          }
        }
        tcContent = `${mainLine}${noteLine}`;

      // Priority cell content - only show for Failed (F) or Blocked (B) statuses
      // Priority represents bug severity, not test case importance
      const isBugStatus = (status === 'F' || status === 'B');
      let priorityContent = isBugStatus ? (rowObj.priority || '') : '';

      // Jira pill (if present)
      const jiraVal = typeof rowObj.jira === 'undefined' ? '' : rowObj.jira;
      let jiraPill = '';
      if (jiraVal && jiraVal.trim() !== '') {
        const jiraTicket = jiraVal.trim();
        const jiraUrl = `${JIRA_BASE_URL}${jiraTicket}`;
        jiraPill = `<a href="${jiraUrl}" target="_blank" class="jira-pill">${escapeHtml(jiraTicket)}</a>`;
      }
      // Place Jira pill immediately after the test case text (before New! tag or anything else)
      let mainLineWithJira = mainLine;
      if (jiraPill) {
        mainLineWithJira = mainLine.replace(/(<\/b>|<\/span>)/, ` ${jiraPill}$1`);
      }
      tcContent = `${mainLineWithJira}${noteLine}`;
      tr.innerHTML = `
        <td class="id-col">${idx + 1}</td>
        <td class="priority-col" data-idx="${idx}" title="Click to change priority">${priorityContent}</td>
        <td class="status-col">
          <button class="status-toggle-btn" data-idx="${idx}" title="${statusText}" style="width:38px; height:22px; border-radius:6px; border:1px solid #bfc7d1; background:${statusColor}; color:#2d3a4a; font-size:12px; font-weight:bold; cursor:pointer; transition:all 0.2s;">${statusSymbol}</button>
        </td>
        <td class="tc-col ${tcClass}" style="${tcStyle}">${tcContent}</td>
      `;

      // Add event listener for priority toggle - only for bug statuses (Failed/Blocked)
      const priorityCell = tr.querySelector('.priority-col');
      if (priorityCell) {
        // Only make clickable for bug statuses
        if (isBugStatus) {
          priorityCell.style.cursor = 'pointer';
          priorityCell.addEventListener('click', function(e) {
            e.stopPropagation();
            const idx = parseInt(priorityCell.getAttribute('data-idx'), 10);
            const currentStatus = csvData[idx].status || 'N';
            // Only allow priority changes for Failed/Blocked
            if (currentStatus !== 'F' && currentStatus !== 'B') return;
            const priorities = ['C', 'H', 'M', 'L'];
            let current = priorities.indexOf(csvData[idx].priority);
            let next = (current + 1) % priorities.length;
            csvData[idx].priority = priorities[next];
            saveToCache && saveToCache();
            renderTable(csvData);
          });
        } else {
          priorityCell.style.cursor = 'default';
          priorityCell.title = 'Priority only applies to Failed/Blocked tests';
        }
      }
      
      // Add event listener for status toggle button
      const statusBtn = tr.querySelector('.status-toggle-btn');
      statusBtn.addEventListener('click', function() {
        const currentStatus = csvData[idx].status || 'N';
        // Cycle through: N -> P -> F -> B -> K -> S -> N
        if (currentStatus === 'N') {
          csvData[idx].status = 'P';
        } else if (currentStatus === 'P') {
          csvData[idx].status = 'F';
        } else if (currentStatus === 'F') {
          csvData[idx].status = 'B';
        } else if (currentStatus === 'B') {
          csvData[idx].status = 'K';
        } else if (currentStatus === 'K') {
          csvData[idx].status = 'S';
        } else {
          csvData[idx].status = 'N';
        }
        saveToCache();
        renderTable(csvData);
      });
      
      const csvTypeInput = tr.querySelector('.csv-type-input');
      if (csvTypeInput) {
        csvTypeInput.addEventListener('change', function() {
          csvData[idx].type = this.value;
          saveToCache();
        });
      }
      
      const csvScopeInput = tr.querySelector('.csv-scope-input');
      if (csvScopeInput) {
        csvScopeInput.addEventListener('change', function() {
          csvData[idx].scope = this.value;
          saveToCache();
        });
      }
      
      const csvPriorityInput = tr.querySelector('.csv-priority-input');
      if (csvPriorityInput) {
        csvPriorityInput.addEventListener('change', function() {
          csvData[idx].priority = this.value;
          saveToCache();
        });
      }
      
      const csvStatusInput = tr.querySelector('.csv-status-input');
      if (csvStatusInput) {
        csvStatusInput.addEventListener('change', function() {
          csvData[idx].status = this.value;
          saveToCache();
        });
      }
      
      const csvCategoryInput = tr.querySelector('.csv-category-input');
      if (csvCategoryInput) {
        csvCategoryInput.addEventListener('change', function() {
          csvData[idx].category = this.value;
          saveToCache();
        });
      }
      
      const csvTestcaseInput = tr.querySelector('.csv-testcase-input');
      if (csvTestcaseInput) {
        csvTestcaseInput.addEventListener('input', function() {
          csvData[idx].testcase = this.value;
          saveToCache();
        });
      }
      
      tbody.appendChild(tr);
      
      // Add double-click event listener to open row editor
      tr.addEventListener('dblclick', function(e) {
        // Don't trigger if clicking on buttons or already editing inputs
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
          return;
        }
        createRowEditor(csvData[idx], idx, tr);
      });
      
      // Also allow clicking on ID column to edit
      const idCell = tr.querySelector('.id-col');
      if (idCell) {
        idCell.style.cursor = 'pointer';
        idCell.title = 'Click to edit this test case';
        idCell.addEventListener('click', function(e) {
          e.stopPropagation();
          createRowEditor(csvData[idx], idx, tr);
        });
      }
      
      // Make row draggable (drag test case cell)
      const tcCell = tr.querySelector('.tc-col');
      if (tcCell) {
        tcCell.setAttribute('draggable', 'true');
        tcCell.style.cursor = 'grab';
          tcCell.addEventListener('dragstart', function(e) {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', idx);
            tr.style.opacity = '0.5';
          });
          tcCell.addEventListener('dragend', function() {
            tr.style.opacity = '';
          });
          tcCell.addEventListener('dragover', function(e) {
            e.preventDefault();
            tr.style.borderTop = '2px solid #4a90e2';
          });
          tcCell.addEventListener('dragleave', function() {
            tr.style.borderTop = '';
          });
          tcCell.addEventListener('drop', function(e) {
            e.preventDefault();
            tr.style.borderTop = '';
            const fromIdx = parseInt(e.dataTransfer.getData('text/plain'), 10);
            const toIdx = idx;
            if (!isNaN(fromIdx) && !isNaN(toIdx) && fromIdx !== toIdx) {
              // Move the row in csvData
              const moved = csvData.splice(fromIdx, 1)[0];
              csvData.splice(toIdx, 0, moved);
              saveToCache();
              renderTable(csvData);
            }
          });
        }
    }); // Close the rows.forEach() block
    } // Close the if (!isCollapsed) block
  }); // Close the categories forEach() block
  
  // Add event listeners for category action buttons
  tbody.querySelectorAll('.cat-action-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const cat = this.getAttribute('data-cat');
      const action = this.getAttribute('data-action');
      // Only affect filtered (visible) rows in this category
      let filtered = csvData
        .map((row, idx) => ({...row, _idx: idx}))
        .filter(row => {
          let execMatch = (filterExecType === 'Both') || (row.type === filterExecType);
          let scopeMatch = false;
          if (filterTestScope === 'Y') {
            scopeMatch = (row.scope === 'Y');
          } else if (filterTestScope === 'S') {
            scopeMatch = (row.scope === 'S' || row.scope === 'Y');
          } else if (filterTestScope === 'R') {
            scopeMatch = (row.scope === 'R' || row.scope === 'S' || row.scope === 'Y');
          }
          // Priority filter only applies to bugs (Failed/Blocked)
          const isBugStatus = (row.status === 'F' || row.status === 'B');
          let priorityMatch = filterPriority.size === 0 || !isBugStatus || filterPriority.has(row.priority);
          return (row.category || 'Uncategorized') === cat && execMatch && scopeMatch && priorityMatch;
        });
      filtered.forEach(rowObj => {
        if (action === 'passed') csvData[rowObj._idx].status = 'P';
        if (action === 'reset') csvData[rowObj._idx].status = 'N';
      });
      saveToCache(); // Save to cache
      renderTable(csvData);
    });
  });

  // Update Jira column header with count
  const jiraHeaderCol = document.getElementById('jiraHeaderCol');
  if (jiraHeaderCol) {
    // Count Jira tickets in currently visible (filtered) rows
    const jiraCount = filtered.filter(row => row.jira && row.jira.trim()).length;
    jiraHeaderCol.innerHTML = `Jira (${jiraCount}) <span id=\"jiraSortIcon\" style=\"font-size: 10px; color: #999;\"></span>`;
    updateJiraSortIcon();
  }

  // Don't update TEST CASE column header count (removed)

  renderCategorySummary(filtered);

  // Calculate the actual displayed count (filtered by selectedCategories)
  let displayedCount = 0;
  let noCategorySelected = false;
  if (selectedCategories === null) {
    displayedCount = 0;
    noCategorySelected = true;
  } else if (selectedCategories.size === 0) {
    displayedCount = filtered.length;
  } else {
    displayedCount = filtered.filter(row => selectedCategories.has(row.category || 'Uncategorized')).length;
  }

  // Add row count display at the bottom of the table
  updateRowCount(displayedCount, data.length, noCategorySelected);
}

// Update row count display
function updateRowCount(filteredCount, totalCount, noCategorySelected = false) {
  let rowCountDiv = document.getElementById('rowCountDisplay');
  if (!rowCountDiv) {
    rowCountDiv = document.createElement('div');
    rowCountDiv.id = 'rowCountDisplay';
    rowCountDiv.style.cssText = 'text-align: center; padding: 12px; color: #6c757d; font-size: 12px; font-weight: 500; border-top: 1px solid #e8ecf1; margin-top: 8px;';
    const tableContainer = document.querySelector('.container');
    if (tableContainer) {
      tableContainer.appendChild(rowCountDiv);
    }
  }

  if (noCategorySelected) {
    rowCountDiv.innerHTML = `<span style="color: #e67e22;">‚ö†Ô∏è Please select at least one Category/Area from the sidebar to view test cases</span>`;
  } else if (filteredCount === totalCount) {
    rowCountDiv.innerHTML = `Showing <strong>${filteredCount}</strong> test case${filteredCount !== 1 ? 's' : ''}`;
  } else {
    rowCountDiv.innerHTML = `Showing <strong>${filteredCount}</strong> of <strong>${totalCount}</strong> test cases`;
  }
}

/* ==========================================
   FILE OPERATIONS - Upload, Download, Export
   ========================================== */

// Custom upload button handler - wrapped in DOMContentLoaded
window.addEventListener('DOMContentLoaded', function() {
  const uploadBtn = document.getElementById('uploadBtn');
  const csvFileInput = document.getElementById('csvFile');
  
  if (uploadBtn && csvFileInput) {
    uploadBtn.addEventListener('click', function() {
      csvFileInput.click();
    });
  }
});

document.addEventListener('DOMContentLoaded', function() {
document.getElementById('csvFile').addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;

  const fileInputElement = e.target;
  const uploadBtn = document.getElementById('uploadBtn');
  const uploadBtnText = uploadBtn.querySelector('.upload-btn-text');

  // Show selected filename in button
  uploadBtnText.textContent = file.name;
  uploadBtn.classList.add('has-file');

  // Read file as text to check format
  const reader = new FileReader();
  reader.onload = function(evt) {
    const fileContent = evt.target.result;
    let csvContent = fileContent;
    
    // Check if this is a .tqt file with sections
    if (file.name.endsWith('.tqt') || fileContent.includes('[CONFIG]') || fileContent.includes('[NOTES]') || fileContent.includes('[DATA]')) {
      const parsed = parseTQTFile(fileContent);
      csvContent = parsed.data;
      testingNotes = parsed.notes;

      // Update notes textarea
      const notesTextarea = document.getElementById('testingNotesTextarea');
      if (notesTextarea) {
        notesTextarea.value = testingNotes;
      }

      // Load custom filters from file
      if (parsed.customFilters && parsed.customFilters.length > 0) {
        customFilters = parsed.customFilters;
        if (typeof window.renderCustomFilters === 'function') {
          window.renderCustomFilters();
        }
      }

      // Apply config settings from file
      if (parsed.config) {
        applyConfigSettings(parsed.config);
      }
    } else {
      // Legacy CSV file - clear notes
      testingNotes = '';
      const notesTextarea = document.getElementById('testingNotesTextarea');
      if (notesTextarea) {
        notesTextarea.value = '';
      }
    }
    
    // Parse CSV content
    Papa.parse(csvContent, {
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        csvData = results.data.map((row, index) => ({
          ...row,
          id: index + 1, // Auto-generate ID based on row position
          status: row.status !== undefined && row.status !== '' ? row.status : 'N',
          notes: row.notes !== undefined ? row.notes : '',
          type: row.type !== undefined ? row.type : '',
          scope: row.scope !== undefined ? row.scope : '',
          priority: row.priority !== undefined ? row.priority : 'P2',
          age: row.age !== undefined ? row.age : ''
        }));

        // Reset all filters to default after upload
        filterExecType = 'Both';
        filterTestScope = 'R';
        filterAge = 'Both';
        filterPriority = new Set(['C', 'H', 'M', 'L']);
        filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);
        filterTestCase = '';
        collapsedCategories = new Set();
        selectedCategories = new Set();

        // Reset filter UI controls
        // Exec type radios
        document.querySelectorAll('input[name="execType"]').forEach(r => {
          if (r.value === 'Both') r.checked = true;
          else r.checked = false;
        });
        // Test scope radios
        document.querySelectorAll('input[name="testScope"]').forEach(r => {
          if (r.value === 'R') r.checked = true;
          else r.checked = false;
        });
        // Age filter radios
        document.querySelectorAll('input[name="ageFilter"]').forEach(r => {
          if (r.value === 'Both') r.checked = true;
          else r.checked = false;
        });
        // Priority checkboxes
        document.querySelectorAll('input[name="priority"]').forEach(cb => cb.checked = true);
        // Status checkboxes/buttons (if any)
        document.querySelectorAll('input[name="status"], .status-filter-btn').forEach(cb => {
          if (cb.tagName === 'INPUT') cb.checked = true;
          else cb.classList.add('active');
        });
        // Keyword filter
        const tcFilter = document.getElementById('testCaseFilter');
        if (tcFilter) tcFilter.value = '';

        // Clean up priorities for non-bug statuses (Priority only applies to Failed/Blocked)
        const cleanedCount = cleanupPrioritiesForNonBugs();
        if (cleanedCount > 0) {
          console.log(`Cleaned ${cleanedCount} priorities from non-bug statuses in uploaded file`);
        }

        saveToCache(); // Save to cache
        renderTable(csvData);

        // Reset the file input to allow re-uploading the same file (but keep filename displayed)
        setTimeout(() => {
          fileInputElement.value = '';
        }, 100);
      }
    });
  };
  reader.readAsText(file);
});
}); // End DOMContentLoaded for file upload

// Priority filter checkboxes replaced by buttons above
// NOTE: Sidebar radio listeners (execType, testScope, ageFilter) are attached in the main DOMContentLoaded block around line 1209

// Helper function to generate base filename
function generateBaseFileName() {
  // Get today's date and time in YYYY-MM-DD_HHMM
  const today = new Date();
  const yyyy = today.getFullYear();
  const mm = String(today.getMonth() + 1).padStart(2, '0');
  const dd = String(today.getDate()).padStart(2, '0');
  const hour = String(today.getHours()).padStart(2, '0');
  const min = String(today.getMinutes()).padStart(2, '0');
  const datePrefix = `${yyyy}-${mm}-${dd}`;
  const timePart = `${hour}${min}`;
  // Get values from new textboxes
  const team = (document.getElementById('teamInput')?.value || '').trim();
  const env = (document.getElementById('envInput')?.value || '').trim();
  const release = (document.getElementById('releaseInput')?.value || '').trim();
  const notes = (document.getElementById('notesInput')?.value || '').trim();
  // Build filename
  let filenameParts = [datePrefix, timePart];
  if (team) filenameParts.push(team);
  if (env) filenameParts.push(env);
  if (release) filenameParts.push(release);
  if (notes) filenameParts.push(notes);
  return filenameParts.join('_');
}

// Download CSV button - now saves as .tqt format
document.getElementById('downloadCsvBtn').addEventListener('click', function() {
  if (!csvData.length) return;
  const baseFileName = generateBaseFileName();
  if (!baseFileName) return;
  
  // Get current notes from textarea
  const notesTextarea = document.getElementById('testingNotesTextarea');
  if (notesTextarea) {
    testingNotes = notesTextarea.value;
  }
  
  // Filter out rows that are empty or only have status 'N' with no other data
  const filteredData = csvData.filter(row => {
    // Remove rows that only have status 'N' and nothing else
    if (row.status === 'N' && !row.type && !row.scope && !row.priority && !row.category && !row.testcase && !row.notes && !row.jira) {
      return false;
    }
    // Remove completely empty rows
    if (!row.type && !row.scope && !row.priority && !row.status && !row.category && !row.testcase && !row.notes && !row.jira) {
      return false;
    }
    return true;
  });
  
  // Preserve original order from csvData (don't sort alphabetically)
  // Priority should be '-' for non-bug statuses (not F or B)
  let csvOut = filteredData.map(row => {
    const isBugStatus = row.status === 'F' || row.status === 'B';
    const priority = isBugStatus ? (row.priority || 'M') : '-';
    return {
      type: row.type,
      scope: row.scope,
      age: typeof row.age === 'undefined' ? '' : row.age,
      priority: priority,
      status: row.status,
      category: row.category,
      testcase: row.testcase,
      notes: typeof row.notes === 'undefined' ? '' : row.notes,
      jira: typeof row.jira === 'undefined' ? '' : row.jira
    };
  });
  // Insert blank line when category changes
  let csvRows = [];
  let lastCategory = null;
  // Add header - correct order: type,scope,age,priority,status,category,testcase,notes,jira
  csvRows.push(['type','scope','age','priority','status','category','testcase','notes','jira']);
  csvOut.forEach(row => {
    if (lastCategory !== null && row.category !== lastCategory) {
      csvRows.push([]); // blank line (empty array instead of array of empty strings)
    }
    csvRows.push([
      row.type,
      row.scope,
      row.age,
      row.priority,
      row.status,
      row.category,
      row.testcase,
      row.notes,
      row.jira
    ]);
    lastCategory = row.category;
  });
  const csv = Papa.unparse(csvRows, {header: false});
  
  // Generate .tqt file with sections
  const tqtContent = generateTQTFile(fileConfig, testingNotes, csv);
  
  const tqtFileName = baseFileName + '.tqt';
  const blob = new Blob([tqtContent], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = tqtFileName;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// Download TXT summary button
document.getElementById('downloadTxtBtn').addEventListener('click', function() {
  if (!csvData.length) return;
  const baseFileName = generateBaseFileName();
  if (!baseFileName) return;
  
  // Get env for summary
  const env = (document.getElementById('envInput')?.value || '').trim();
  
  // Prepare summary
  // Group by category for percentages and failed cases
  const catMap = {};
  const failedMap = {};
  csvData.forEach(row => {
    const cat = row.category || 'Uncategorized';
    if (!catMap[cat]) catMap[cat] = { total: 0, tested: 0 };
    catMap[cat].total++;
    if (row.status && row.status !== 'N') catMap[cat].tested++;
    if (row.status === 'F') {
      if (!failedMap[cat]) failedMap[cat] = [];
      failedMap[cat].push(row.testcase);
    }
  });
  // Extract date and time from baseFileName (assume starts with YYYY-MM-DD_HHMM)
  let summaryDate = '';
  let summaryTime = '';
  let summaryEnv = '';
  const dateTimeMatch = baseFileName.match(/(\d{4}-\d{2}-\d{2})_(\d{4})_([a-zA-Z]+)/);
  if (dateTimeMatch) {
    summaryDate = dateTimeMatch[1];
    summaryTime = dateTimeMatch[2];
    summaryEnv = dateTimeMatch[3];
  }
  let summary = 'Test Case Summary\n\n';
  if (summaryDate) summary += `Date: ${summaryDate}`;
  if (summaryTime) summary += `  Time: ${summaryTime.slice(0,2)}:${summaryTime.slice(2,4)}`;
  if (env) summary += `  Environment: ${env}\n\n`;
  else summary += '\n\n';
  
  // Add testing notes if available
  const testingNotesTextarea = document.getElementById('testingNotes');
  const testingNotes = testingNotesTextarea ? testingNotesTextarea.value.trim() : '';
  if (testingNotes) {
    summary += 'Testing Notes:\n';
    summary += testingNotes + '\n\n';
  }
  
  Object.entries(catMap).forEach(([cat, val]) => {
    const percent = val.total ? Math.round((val.tested/val.total)*100) : 0;
    summary += `${cat}: ${percent}% tested\n`;
  });
  summary += '\nFailed Test Cases by Category:\n';
  Object.entries(failedMap).forEach(([cat, fails]) => {
    if (fails.length) {
      summary += `\n${cat} - Failed:\n`;
      // Find failed rows for this category with notes
      csvData.forEach(row => {
        if ((row.category || 'Uncategorized') === cat && row.status === 'F') {
          let note = row.notes ? ` [${row.notes}]` : '';
          summary += `- ${row.testcase}${note}\n`;
        }
      });
    }
  });
  const summaryFileName = baseFileName + '.txt';
  const blob = new Blob([summary], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = summaryFileName;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// Add style for failed test case cell ONCE
if (!document.getElementById('tc-failed-style')) {
  const style = document.createElement('style');
  style.id = 'tc-failed-style';
  style.innerHTML = `.tc-failed { font-weight: normal !important; color: #d60000 !important; }`;
  document.head.appendChild(style);
}

// Load cached data on page load
window.addEventListener('DOMContentLoaded', function() {
  loadFromCache();
  // Render custom filters after cache is loaded (if the function is available)
  if (typeof window.renderCustomFilters === 'function') {
    window.renderCustomFilters();
  }
  
  // Add event listener for testing notes textarea
  const notesTextarea = document.getElementById('testingNotesTextarea');
  if (notesTextarea) {
    // Save on input
    notesTextarea.addEventListener('input', function(e) {
      saveToCache();
      
      // Auto-convert dashes to bullet points
      const cursorPos = this.selectionStart;
      const textBefore = this.value.substring(0, cursorPos);
      const textAfter = this.value.substring(cursorPos);
      
      // Check if user just typed "- " at the start of a line
      if (textBefore.endsWith('- ')) {
        const lastNewlineIndex = textBefore.lastIndexOf('\n', textBefore.length - 3);
        const lineStart = lastNewlineIndex === -1 ? 0 : lastNewlineIndex + 1;
        const beforeLine = textBefore.substring(0, lineStart);
        const afterDash = textBefore.substring(lineStart + 2); // Skip "- "
        
        this.value = beforeLine + '‚Ä¢ ' + afterDash + textAfter;
        this.selectionStart = this.selectionEnd = cursorPos;
      }
    });
  }

  // Add event listeners for filename input fields
  const teamInput = document.getElementById('teamInput');
  const envInput = document.getElementById('envInput');
  const releaseInput = document.getElementById('releaseInput');
  const notesInput = document.getElementById('notesInput');
  
  if (teamInput) {
    teamInput.addEventListener('change', saveToCache);
  }
  if (envInput) {
    envInput.addEventListener('change', saveToCache);
  }
  if (releaseInput) {
    releaseInput.addEventListener('input', saveToCache);
  }
  if (notesInput) {
    notesInput.addEventListener('input', saveToCache);
  }
  
  // Attach sidebar STATUS checkbox listeners (ensure this is always run after DOM is ready)
  const statusCheckboxes = document.querySelectorAll('#prioritySidebar input[type="checkbox"][name="status"]');
  statusCheckboxes.forEach(cb => {
    cb.addEventListener('change', function() {
      const status = this.value;
      if (this.checked) {
        filterStatus.add(status);
      } else {
        filterStatus.delete(status);
      }
      // Clear all quick/custom filter highlights when manually changing filters
      if (typeof window.clearAllFilterButtonHighlights === 'function') {
        window.clearAllFilterButtonHighlights();
      }
      saveToCache();
      checkQuickFilterMatch();
      renderTable(csvData);
    });
  });
  // On load, sync status checkbox states
  statusCheckboxes.forEach(cb => {
    cb.checked = filterStatus.has(cb.value);
  });
  
  // Add event listener for test case filter input
  const testCaseFilterInput = document.getElementById('testCaseFilter');
  if (testCaseFilterInput) {
    testCaseFilterInput.addEventListener('input', function() {
      filterTestCase = this.value;
      renderTable(csvData);
    });
  }
  
  // Add event listener for Reset All Filters button (sidebar)
  const resetFiltersBtn = document.getElementById('resetFiltersBtn');
  if (resetFiltersBtn) {
    resetFiltersBtn.addEventListener('click', function(e) {
      // Check for edit mode
      if (typeof promptEditModeExit === 'function' && promptEditModeExit(e)) {
        e.preventDefault();
        return;
      }

      // Reset sidebar radio filters
      filterExecType = 'Both';
      filterTestScope = 'R';
      filterAge = 'Both';
      document.querySelector('input[name="execType"][value="Both"]').checked = true;
      document.querySelector('input[name="testScope"][value="R"]').checked = true;
      document.querySelector('input[name="ageFilter"][value="Both"]').checked = true;

      // Reset priority to all selected
      filterPriority = new Set(['C', 'H', 'M', 'L']);
      document.querySelectorAll('.priority-filter-btn').forEach(btn => btn.classList.add('active'));

      // Reset status filters to all selected
      filterStatus = new Set(['N', 'P', 'F', 'B', 'K', 'S']);
      document.querySelectorAll('input[name="status"]').forEach(cb => cb.checked = true);
      document.querySelectorAll('.status-filter-btn').forEach(btn => btn.classList.add('active'));

      // Clear test case search
      filterTestCase = '';
      const testCaseInput = document.getElementById('testCaseFilter');
      if (testCaseInput) testCaseInput.value = '';

      // Reset category and jira filters
      selectedCategories.clear();
      jiraFilter = 'all';
      if (typeof updateJiraFilterButton === 'function') updateJiraFilterButton();
      if (typeof updateCategoryDropdownLabel === 'function') updateCategoryDropdownLabel();

      // Reset special filters (pin, question, retest, pending jira, cleanup)
      if (typeof resetSpecialFilters === 'function') resetSpecialFilters();

      // Update quick filter highlight and re-render
      checkQuickFilterMatch();
      saveToCache();
      renderTable(csvData);
    });
  }
  
  // Add event listener for toggle all categories button
  const toggleAllBtn = document.getElementById('toggleAllCategoriesBtn');
  if (toggleAllBtn) {
    toggleAllBtn.addEventListener('click', function() {
      // If any categories are collapsed, expand all. Otherwise, collapse all
      if (collapsedCategories.size > 0) {
        // Expand all
        collapsedCategories.clear();
        this.classList.remove('collapsed');
      } else {
        // Collapse all
        const categories = new Set();
        csvData.forEach(row => {
          if (row.category) {
            categories.add(row.category);
          }
        });
        collapsedCategories = new Set(categories);
        this.classList.add('collapsed');
      }
      renderTable(csvData);
    });
  }
  
  // Add progress bar tooltip handlers
  setupProgressBarTooltips();
});

/* ==========================================
   UI HELPERS - Tooltips, Scroll Navigation, Copy
   ========================================== */

// Setup instant tooltips for progress bar segments
function setupProgressBarTooltips() {
  // Create a shared tooltip element
  let tooltip = document.getElementById('progress-tooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'progress-tooltip';
    tooltip.style.cssText = `
      position: fixed;
      background: #2d3a4a;
      color: #ffffff;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      white-space: nowrap;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
      z-index: 10000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease;
    `;
    document.body.appendChild(tooltip);
  }
  
  // Delegate event handlers for dynamically rendered progress fills
  document.addEventListener('mouseover', function(e) {
    if (e.target.classList.contains('category-progress-fill')) {
      const tooltipText = e.target.getAttribute('data-tooltip');
      if (tooltipText) {
        const rect = e.target.getBoundingClientRect();
        tooltip.textContent = tooltipText;
        tooltip.style.left = (rect.left + rect.width / 2) + 'px';
        tooltip.style.top = (rect.top - 8) + 'px';
        tooltip.style.transform = 'translate(-50%, -100%)';
        tooltip.style.opacity = '1';
      }
    }
  });
  
  document.addEventListener('mouseout', function(e) {
    if (e.target.classList.contains('category-progress-fill')) {
      tooltip.style.opacity = '0';
    }
  });
}

// Scroll navigation buttons functionality
window.addEventListener('DOMContentLoaded', function() {
  const scrollToDashboardBtn = document.getElementById('scrollToDashboardBtn');
  const scrollToTableBtn = document.getElementById('scrollToTableBtn');
  const scrollToMiddleBtn = document.getElementById('scrollToMiddleBtn');
  const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');
  const testTable = document.getElementById('testTable');
  const metricsOverview = document.getElementById('metricsOverview');

  if (scrollToDashboardBtn && scrollToTableBtn && scrollToMiddleBtn && scrollToBottomBtn && testTable) {
    // Update button visibility based on scroll position
    function updateNavButtonVisibility() {
      const tableRect = testTable.getBoundingClientRect();
      const tableTop = tableRect.top;
      const tableBottom = tableRect.bottom;
      const viewportHeight = window.innerHeight;
      const tableHeight = testTable.offsetHeight;

      // Calculate position zones
      const atDashboard = tableTop > 150; // Table not yet in view (at dashboard area)
      const atTableHeader = tableTop >= -50 && tableTop <= 150; // At or near table header
      const atTableMiddle = tableTop < -50 && tableBottom > viewportHeight + 100; // In middle of table
      const atTableBottom = tableBottom <= viewportHeight + 100; // Near or at bottom of table

      // Dashboard button: hide when at dashboard, show otherwise
      scrollToDashboardBtn.classList.toggle('nav-hidden', atDashboard);

      // Table button: hide when at table header, show otherwise
      scrollToTableBtn.classList.toggle('nav-hidden', atTableHeader);

      // Middle button: hide when at middle (but this is tricky - show most of the time)
      // Only hide if table is very small or we're in the middle zone
      const isSmallTable = tableHeight < viewportHeight * 2;
      scrollToMiddleBtn.classList.toggle('nav-hidden', isSmallTable && atTableMiddle);

      // Bottom button: hide when at bottom of table
      scrollToBottomBtn.classList.toggle('nav-hidden', atTableBottom);
    }

    // Throttle scroll events for performance
    let scrollTimeout;
    window.addEventListener('scroll', function() {
      if (scrollTimeout) return;
      scrollTimeout = setTimeout(function() {
        scrollTimeout = null;
        updateNavButtonVisibility();
      }, 50);
    });

    // Initial update
    updateNavButtonVisibility();

    // Scroll to dashboard (top of page)
    scrollToDashboardBtn.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });

    // Scroll to table header
    scrollToTableBtn.addEventListener('click', function() {
      testTable.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });

    // Scroll to table middle (approximate)
    scrollToMiddleBtn.addEventListener('click', function() {
      const tableRect = testTable.getBoundingClientRect();
      const tableHeight = testTable.offsetHeight;
      const targetScroll = window.scrollY + tableRect.top + (tableHeight * 0.4);
      window.scrollTo({ top: targetScroll, behavior: 'smooth' });
    });

    // Scroll to bottom of table
    scrollToBottomBtn.addEventListener('click', function() {
      const tableRect = testTable.getBoundingClientRect();
      const tableHeight = testTable.offsetHeight;
      const targetScroll = window.scrollY + tableRect.top + (tableHeight * 0.85);
      window.scrollTo({ top: targetScroll, behavior: 'smooth' });
    });
  }
});

// Setup copy button for Failed Test Cases section
function setupFailedCopyButton() {
  const copyBtn = document.getElementById('copyFailedBtn');
  if (!copyBtn) return;
  
  // Remove old event listener if exists
  const newBtn = copyBtn.cloneNode(true);
  copyBtn.parentNode.replaceChild(newBtn, copyBtn);
  
  newBtn.addEventListener('click', function() {
    const failedDiv = document.getElementById('failedList');
    const copyText = failedDiv.getAttribute('data-copy-text');
    
    if (!copyText || copyText.trim() === 'Failed Test Cases:\n\n') {
      // No content to copy
      return;
    }
    
    navigator.clipboard.writeText(copyText).then(() => {
      // Change button appearance
      this.textContent = 'Copied!';
      this.classList.add('copied');
      
      // Reset button after 5 seconds
      setTimeout(() => {
        this.textContent = 'Copy';
        this.classList.remove('copied');
      }, 5000);
    }).catch(err => {
      console.error('Failed to copy:', err);
      this.textContent = 'Error';
      setTimeout(() => {
        this.textContent = 'Copy';
      }, 3000);
    });
  });
}
